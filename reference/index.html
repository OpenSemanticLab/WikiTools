<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://OpenSemanticLab.github.io/Tools/reference/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Reference - OpenSemanticLab Python Package (osl)</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
        <link href="../assets/_mkdocstrings.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Reference";
        var mkdocs_page_input_path = "reference.md";
        var mkdocs_page_url = "/Tools/reference/";
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> OpenSemanticLab Python Package (osl)
        </a>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">Reference</a>
    <ul class="current">
    </ul>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">OpenSemanticLab Python Package (osl)</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" alt="Docs"></a> &raquo;</li>
      <li>Reference</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <p>This part of the project documentation focuses on
an <strong>information-oriented</strong> approach. Use it as a
reference for the technical implementation of the
<code>osl tools</code> project code.</p>


<div class="doc doc-object doc-module">


<a id="wiki_tools"></a>
  <div class="doc doc-contents first">

  

  <div class="doc doc-children">









<div class="doc doc-object doc-function">



<h2 id="wiki_tools.copy_list_of_wiki_pages" class="doc doc-heading">
<code class="highlight language-python">copy_list_of_wiki_pages(title_list, site0, site1, overwrite, callback=None)</code>

</h2>


  <div class="doc doc-contents ">
  
      <h4 id="wiki_tools.copy_list_of_wiki_pages--parameters">Parameters</h4>
<p>title_list : list</p>

<details class="site0-">
  <summary>mwclient.client.Site</summary>
  <p>Source site object from mwclient lib</p>
</details>
<details class="site1-">
  <summary>mwclient.client.Site</summary>
  <p>Target site object from mwclient lib</p>
</details>
<details class="overwrite-">
  <summary>bool</summary>
  <p>Whether to overwrite existing pages at target site</p>
</details>
<details class="callback-">
  <summary>NoneType or function</summary>
  <p>Function passed over, to perform operation on the titles of the source pages and to be passed as title of the
target pages. See examples below.
Example functions:
    capitalize = lambda x: x.capitalize()
    def change_namespace(title, namespace):
        if ":" in namespace:
            namespace = namespace.split(":")[0]
        if ":" in title:
            splits = title.split(":")
            old_name = splits[1].capitalize()
            new_title = namespace + ":" + old_name
        else:
            new_title = namespace + ":" + title.capitalize()
        return new_title
Examples of passing a function as parameter:
    callback = capitalize
    callback = lambda x: x.lower()</p>
</details>      <h4 id="wiki_tools.copy_list_of_wiki_pages--returns">Returns</h4>

<details class="results_dict-">
  <summary>dict</summary>
  <p>Dictionary, containing the results of the copying operations</p>
</details>
      <details class="quote">
        <summary>Source code in <code>src/wiki_tools.py</code></summary>
        <pre class="highlight"><code class="language-python">def copy_list_of_wiki_pages(title_list, site0, site1, overwrite, callback=None):
    """

    Parameters
    ----------
    title_list : list
    site0 : mwclient.client.Site
        Source site object from mwclient lib
    site1 : mwclient.client.Site
        Target site object from mwclient lib
    overwrite : bool
        Whether to overwrite existing pages at target site
    callback : NoneType or function
        Function passed over, to perform operation on the titles of the source pages and to be passed as title of the
        target pages. See examples below.
        Example functions:
            capitalize = lambda x: x.capitalize()
            def change_namespace(title, namespace):
                if ":" in namespace:
                    namespace = namespace.split(":")[0]
                if ":" in title:
                    splits = title.split(":")
                    old_name = splits[1].capitalize()
                    new_title = namespace + ":" + old_name
                else:
                    new_title = namespace + ":" + title.capitalize()
                return new_title
        Examples of passing a function as parameter:
            callback = capitalize
            callback = lambda x: x.lower()

    Returns
    -------
    results_dict : dict
        Dictionary, containing the results of the copying operations
    """

    success_list = list()
    fail_list = list()
    for title0 in title_list:
        if callback is None:
            title1 = title0
        else:
            title1 = callback(title0)
        success = copy_wiki_page(title0, title1, site0, site1, overwrite)
        if success:
            success_list.append(title1)
        else:
            fail_list.append(title1)
    results_dict = {"Successfully copied pages": success_list, "Pages failed to copy": fail_list}
    return results_dict</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="wiki_tools.copy_wiki_page" class="doc doc-heading">
<code class="highlight language-python">copy_wiki_page(title0, title1, site0, site1, overwrite=True)</code>

</h2>


  <div class="doc doc-contents ">
  
      <h4 id="wiki_tools.copy_wiki_page--parameters">Parameters</h4>

<details class="title0-">
  <summary>str</summary>
  <p>Title of the source page</p>
</details>
<details class="title1-">
  <summary>str</summary>
  <p>Title of the target page</p>
</details>
<details class="site0-">
  <summary>mwclient.client.Site</summary>
  <p>Source site object from mwclient lib</p>
</details>
<details class="site1-">
  <summary>mwclient.client.Site</summary>
  <p>Target site object from mwclient lib</p>
</details>
<details class="overwrite-">
  <summary>bool</summary>
  <p>Whether to overwrite existing pages at target site</p>
</details>      <h4 id="wiki_tools.copy_wiki_page--returns">Returns</h4>
<p>success: bool</p>

      <details class="quote">
        <summary>Source code in <code>src/wiki_tools.py</code></summary>
        <pre class="highlight"><code class="language-python">def copy_wiki_page(title0, title1, site0, site1, overwrite=True):
    """

    Parameters
    ----------
    title0 : str
        Title of the source page
    title1 : str
        Title of the target page
    site0 : mwclient.client.Site
        Source site object from mwclient lib
    site1 : mwclient.client.Site
        Target site object from mwclient lib
    overwrite : bool
        Whether to overwrite existing pages at target site

    Returns
    -------
    success: bool

    """
    if title0.lower() == title1.lower() and site0 == site1:
        # copy on it self = no action necessary
        success = True
    else:
        page0 = site0.pages[title0]
        content = page0.text()
        if overwrite:
            success = create_or_overwrite_wiki_page(title1, content, site1)
        else:
            search_result = search_wiki_page(title1, site1)
            if search_result["Result"] and search_result["Exact match"]:  # page already exists
                success = False
            else:  # search_result["Result"] == True/False, search_result["Exact match"] == False
                success = create_or_overwrite_wiki_page(title1, content, site1)
    return success</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="wiki_tools.create_flat_content_structure_from_wikitext" class="doc doc-heading">
<code class="highlight language-python">create_flat_content_structure_from_wikitext(text, array_mode='force')</code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Create a flat python dict (aka 'flat_content_structure' = 'wikiJson') representing the content of the page</p>
<h4 id="wiki_tools.create_flat_content_structure_from_wikitext--parameters">Parameters</h4>

<details class="text-">
  <summary>str</summary>
  <p>the wiki source text</p>
</details>
<details class="array_mode-">
  <summary>str</summary>
  <p>defines how to parse template params
array_mode / param     value   value;  value;value     comment
'force':               array   array   array           always create an array
'only_multiple':       literal literal array           create only when more than one value is given
'delimiter_present':   literal array   array           create array if at least one separator char is present</p>
</details>      <h4 id="wiki_tools.create_flat_content_structure_from_wikitext--returns">Returns</h4>

<details class="res-">
  <summary>dict</summary>
  <p>(aka 'flat_content_structure' = 'wikiJson')</p>
</details>
      <details class="quote">
        <summary>Source code in <code>src/wiki_tools.py</code></summary>
        <pre class="highlight"><code class="language-python">def create_flat_content_structure_from_wikitext(text: str, array_mode: str = 'force'):
    """Create a flat python dict (aka 'flat_content_structure' = 'wikiJson') representing the content of the page

    Parameters
    ----------
    text : str
        the wiki source text
    array_mode : str
        defines how to parse template params
        array_mode / param     value   value;  value;value     comment
        'force':               array   array   array           always create an array
        'only_multiple':       literal literal array           create only when more than one value is given
        'delimiter_present':   literal array   array           create array if at least one separator char is present

    Returns
    -------
    res : dict
        (aka 'flat_content_structure' = 'wikiJson')
    """

    res = []
    text = text.strip()
    existing_code = mwparserfromhell.parse(text)
    t_count = 0
    for i in range(0, len(existing_code.nodes)):
        n = existing_code.nodes.pop(0) #returns first layer of nodes. filter() returns also template args
        if (type(n) is mwparserfromhell.nodes.template.Template):
            t_count += 1
            wt = {}
            #print(f"Template: {t.name} = {t}")
            wt[str(n.name).strip()] = {}
            for p in n.params:
                #print(f"  Param: {p.name} = {p.value} ({type(p.value)})")
                wt[str(n.name).strip()][str(p.name)] = create_flat_content_structure_from_wikitext(str(p.value), array_mode)
            res.append(wt)
        else:
            if len(res) == 0 or type(res[-1]) is dict:
                res.append("")
            res[-1] = res[-1] + str(n) #append to previos string if exists
    #for i, x in enumerate(res):
    #    if type(x) is str: res[i] = x.strip() #remove whitespace 
    res = [x for x in res if x and not (type(x) is str and x.isspace())]
    if t_count == 0: 
        res = text
        values = str(text).strip().split(';')
        if array_mode == 'force': res = values
        elif array_mode == 'only_multiple' and len(values) &gt; 1: res = values
        elif array_mode == 'separator_present' and ';' in text: res = values
    return res</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="wiki_tools.create_or_overwrite_wiki_page" class="doc doc-heading">
<code class="highlight language-python">create_or_overwrite_wiki_page(title, content, site)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Creates a page with the passed title and content. If the page already exists, the prior content is replaced with
the passed content.</p>
<h4 id="wiki_tools.create_or_overwrite_wiki_page--parameters">Parameters</h4>

<details class="title-">
  <summary>str</summary>
  <p>Title of the wiki page, e. g. User:Someone1234</p>
</details>      <p>content : str</p>

<details class="site-">
  <summary>mwclient.client.Site</summary>
  <p>Site object from mwclient lib</p>
</details>      <h4 id="wiki_tools.create_or_overwrite_wiki_page--returns">Returns</h4>
<p>success : bool</p>

      <details class="quote">
        <summary>Source code in <code>src/wiki_tools.py</code></summary>
        <pre class="highlight"><code class="language-python">def create_or_overwrite_wiki_page(title, content, site):
    """Creates a page with the passed title and content. If the page already exists, the prior content is replaced with
    the passed content.

    Parameters
    ----------
    title : str
        Title of the wiki page, e. g. User:Someone1234
    content : str
    site : mwclient.client.Site
        Site object from mwclient lib

    Returns
    -------
    success : bool
    """
    target_page = site.pages[title]
    target_page.edit(content, '[bot] create page')
    success = True
    return success</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="wiki_tools.create_or_update_wiki_page_with_template" class="doc doc-heading">
<code class="highlight language-python">create_or_update_wiki_page_with_template(title, content, site, overwrite_with_empty=False)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Creates a wiki page with a template included in the content. If the page does already exist, the parameters
within the template are update</p>
<h4 id="wiki_tools.create_or_update_wiki_page_with_template--parameters">Parameters</h4>

<details class="title-">
  <summary>str</summary>
  <p>Title of the wiki page, e. g. User:Someone1234</p>
</details>      <p>content : str</p>

<details class="site-">
  <summary>mwclient.client.Site</summary>
  <p>Site object from mwclient lib</p>
</details>
<details class="overwrite_with_empty-">
  <summary>bool</summary>
  <p>Decided whether a template parameter's value in an preexisting page is overwritten with an empty value</p>
</details>      <h4 id="wiki_tools.create_or_update_wiki_page_with_template--returns">Returns</h4>
<p>success : bool</p>

      <details class="quote">
        <summary>Source code in <code>src/wiki_tools.py</code></summary>
        <pre class="highlight"><code class="language-python">def create_or_update_wiki_page_with_template(title, content, site, overwrite_with_empty=False):
    """Creates a wiki page with a template included in the content. If the page does already exist, the parameters
    within the template are update

    Parameters
    ----------
    title : str
        Title of the wiki page, e. g. User:Someone1234
    content : str
    site : mwclient.client.Site
        Site object from mwclient lib
    overwrite_with_empty : bool
        Decided whether a template parameter's value in an preexisting page is overwritten with an empty value

    Returns
    -------
    success : bool
    """
    search_result = search_wiki_page(title, site)
    if search_result["Result"]:
        existing_page = site.pages[title]
        existing_text = existing_page.text()
        # update the page's content (template only)
        updated_content = update_template_within_wikitext(text=existing_text, template_text=content, overwrite_with_empty=overwrite_with_empty)
        success = create_or_overwrite_wiki_page(title, updated_content, site)
    else:
        # just create the page
        success = create_or_overwrite_wiki_page(title, content, site)
    return success</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="wiki_tools.create_site_object" class="doc doc-heading">
<code class="highlight language-python">create_site_object(domain, password_file='')</code>

</h2>


  <div class="doc doc-contents ">
  
      <pre><code>Parameters
----------
domain : str
password_file : str (path to file with &lt;username&gt;
</code></pre>
<p><password>)</p>
<pre><code>Returns
-------
site : mwclient.client.Site
    Site object from mwclient lib
</code></pre>

      <details class="quote">
        <summary>Source code in <code>src/wiki_tools.py</code></summary>
        <pre class="highlight"><code class="language-python">def create_site_object(domain, password_file=""):
    """

    Parameters
    ----------
    domain : str
    password_file : str (path to file with &lt;username&gt;\n&lt;password&gt;)

    Returns
    -------
    site : mwclient.client.Site
        Site object from mwclient lib
    """
    domain_dict = {
        "wiki-dev": {"Address": "wiki-dev.open-semantic-lab.org"}
    }
    if domain in domain_dict.keys():
        domain = domain_dict[domain]["Address"]

    site = mwclient.Site(domain, path='/w/')

    if (password_file != ""):
        f=open(password_file,"r")
        lines=f.readlines()
        user=lines[0].strip()
        password=lines[1].strip()
        f.close()
    else:
        user = input("Enter bot username (username@botname)")
        password = getpass.getpass("Enter bot password")

    site.login(user, password)
    del user
    del password
    return site</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="wiki_tools.delete_wiki_page" class="doc doc-heading">
<code class="highlight language-python">delete_wiki_page(title, site, reason)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Deletes the wiki page with the passed title, if it was found (exact match!), otherwise returns False</p>
<h4 id="wiki_tools.delete_wiki_page--parameters">Parameters</h4>

<details class="title-">
  <summary>str</summary>
  <p>Title of the wiki page, e. g. User:Someone1234</p>
</details>
<details class="site-">
  <summary>mwclient.client.Site</summary>
  <p>Site object from mwclient lib</p>
</details>      <p>reason : str</p>
<h4 id="wiki_tools.delete_wiki_page--returns">Returns</h4>
<p>success : bool</p>

      <details class="quote">
        <summary>Source code in <code>src/wiki_tools.py</code></summary>
        <pre class="highlight"><code class="language-python">def delete_wiki_page(title, site, reason):
    """Deletes the wiki page with the passed title, if it was found (exact match!), otherwise returns False

    Parameters
    ----------
    title : str
        Title of the wiki page, e. g. User:Someone1234
    site : mwclient.client.Site
        Site object from mwclient lib
    reason : str

    Returns
    -------
    success : bool
    """
    try:
        page = site.pages[title]
        page.delete(reason=reason, watch=False, unwatch=True, oldimage=False)
        success = True
    except mwclient.errors.APIError:
        success = False
    return success</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="wiki_tools.edit_wiki_page_with_content_merge" class="doc doc-heading">
<code class="highlight language-python">edit_wiki_page_with_content_merge(title, new_content, site, template_name)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Edits an existing wiki page, while merging the passed new content with the content of the existing page</p>
<h4 id="wiki_tools.edit_wiki_page_with_content_merge--parameters">Parameters</h4>

<details class="title-">
  <summary>str</summary>
  <p>Title of the wiki page, e. g. User:Someone1234</p>
</details>      <p>new_content : str</p>

<details class="site-">
  <summary>mwclient.client.Site</summary>
  <p>Site object from mwclient lib</p>
</details>      <p>template_name : str</p>
<h4 id="wiki_tools.edit_wiki_page_with_content_merge--returns">Returns</h4>
<p>success : bool</p>

      <details class="quote">
        <summary>Source code in <code>src/wiki_tools.py</code></summary>
        <pre class="highlight"><code class="language-python">def edit_wiki_page_with_content_merge(title, new_content, site, template_name):
    """Edits an existing wiki page, while merging the passed new content with the content of the existing page

    Parameters
    ----------
    title : str
        Title of the wiki page, e. g. User:Someone1234
    new_content : str
    site : mwclient.client.Site
        Site object from mwclient lib
    template_name : str

    Returns
    -------
    success : bool
    """
    search_result = search_wiki_page(title, site)
    if search_result["Result"]:
        source_page = site.pages[title]
        source_page_content = source_page.text()
        # todo: test function
        new_content = merge_wiki_page_text(new_content, source_page_content, template_name=template_name)
        target_page = site.pages[title]
        target_page.edit(new_content, '[bot] update of page content')
        success = True
    else:
        success = False
    return success</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="wiki_tools.extend_page_list_with_recursive_dependencies" class="doc doc-heading">
<code class="highlight language-python">extend_page_list_with_recursive_dependencies(page_list, site)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Finds all included templates, properties and categories for a list of wiki pages and appends them to the list</p>
<h4 id="wiki_tools.extend_page_list_with_recursive_dependencies--parameters">Parameters</h4>

<details class="page_list-">
  <summary>list or iterable</summary>
  <p>List of pages</p>
</details>
<details class="site-">
  <summary>mwclient.client.Site</summary>
  <p>Site object from mwclient lib</p>
</details>      <h4 id="wiki_tools.extend_page_list_with_recursive_dependencies--returns">Returns</h4>
<p>page_list : list</p>

      <details class="quote">
        <summary>Source code in <code>src/wiki_tools.py</code></summary>
        <pre class="highlight"><code class="language-python">def extend_page_list_with_recursive_dependencies(page_list, site):
    """Finds all included templates, properties and categories for a list of wiki pages and appends them to the list

    Parameters
    ----------    
    page_list : list or iterable
        List of pages
    site : mwclient.client.Site
        Site object from mwclient lib

    Returns
    -------
    page_list : list
    """
    page_list_iter = copy.deepcopy(page_list)
    for page in page_list_iter:
        # we provide the updates page list to prevent a revisit of the pages
        dependencies = find_dependencies_recursively(page, site, dependencies=page_list, debug=False)
        page_list.extend(dependencies)
    page_list = np.unique(page_list)
    return page_list</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="wiki_tools.find_dependencies" class="doc doc-heading">
<code class="highlight language-python">find_dependencies(wikitext, debug=False)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Finds templates, properties and categories within wikitext</p>
<h4 id="wiki_tools.find_dependencies--parameters">Parameters</h4>
<p>wikitext : str</p>

<details class="debug-">
  <summary>bool</summary>
  <p>Whether to print debugging messages</p>
</details>      <h4 id="wiki_tools.find_dependencies--returns">Returns</h4>
<p>filtered_dependencies : list</p>

      <details class="quote">
        <summary>Source code in <code>src/wiki_tools.py</code></summary>
        <pre class="highlight"><code class="language-python">def find_dependencies(wikitext, debug=False):
    """Finds templates, properties and categories within wikitext

    Parameters
    ----------
    wikitext : str
    debug : bool
        Whether to print debugging messages

    Returns
    -------
    filtered_dependencies : list
    """
    dependencies = []
    code = mwparserfromhell.parse(wikitext)
    for template in code.filter_templates(recursive=True):
        if template.name.split(':')[0].isupper():
            if debug: print("MagicWord: {}".format(template.name))
        elif template.name[0] == "#":
            if debug: print("ParserFunction: {}".format(template.name))
            if "#set:" in template.name or "#declare:" in template.name:
                if '=' in template.name.split(':')[1]:  # in case of '{{#set:HasIdPostfix={{{id_postfix}}} }}'
                    property_ = "Property:" + template.name.split(':')[1].split('=')[0]
                    dependencies.append(property_)
                    if debug: print("=&gt; {}".format(property_))
                for param in template.params:
                    property_ = "Property:" + param.split('=')[0]
                    dependencies.append(property_)
                    if debug: print("=&gt; {}".format(property_))
        else:
            if debug: print("Template: {}".format(template.name))
            template_name = str(template.name)
            if ':' not in template.name:
                template_name = "Template:" + template_name
            dependencies.append(template_name)
            if debug: print("=&gt; {}".format(template_name))
    # for tag in code.filter_tags(recursive=True):
    #    if (debug): print("Tag: {}".format(tag))
    for link in code.filter_wikilinks(recursive=True):
        if '::' in link:
            if debug: print("Annotation: {}".format(link))
            property_ = "Property:" + link.split('::')[0].split('[[')[-1]
            dependencies.append(property_)
            if debug: print("=&gt; {}".format(property_))
        if 'Category:' in link:
            if debug: print("Category: {}".format(link))
            category = link.replace('[[', '').replace(']]', '')
            dependencies.append(str(category))
            if debug: print("=&gt; {}".format(category))
        else:
            if debug: print("Link: {}".format(link))
    dependencies = np.unique(dependencies).tolist()  # remove duplicates
    filtered_dependencies = []  # do not manipulate the iterated object
    for dependency in dependencies:
        # ensure no leading or trailing white spaces 
        dependency = dependency.strip()
        # very frew page titles listed here contain invalid characters "\n"
        dependency = dependency.replace('\n', '')        
        # see https://www.semantic-mediawiki.org/wiki/Help:Special_properties
        if 'Property:' in dependency and (' ' in dependency or '_' in dependency):
            if debug: print("Info: Remove presumptive built-in property {}".format(dependency))
        else:            
            filtered_dependencies.append(dependency)
    return filtered_dependencies</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="wiki_tools.find_dependencies_recursively" class="doc doc-heading">
<code class="highlight language-python">find_dependencies_recursively(title, site, dependencies=[], debug=False)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Finds all included templates, properties and categories within a wiki page</p>
<h4 id="wiki_tools.find_dependencies_recursively--parameters">Parameters</h4>

<details class="title-">
  <summary>str</summary>
  <p>Title of the wiki page, e. g. User:Someone1234</p>
</details>
<details class="site-">
  <summary>mwclient.client.Site</summary>
  <p>Site object from mwclient lib    </p>
</details>      <p>dependencies
    List of already found dependent titles</p>

<details class="debug-">
  <summary>bool</summary>
  <p>Whether to print debugging messages</p>
</details>      <h4 id="wiki_tools.find_dependencies_recursively--returns">Returns</h4>
<p>dependencies : list</p>

      <details class="quote">
        <summary>Source code in <code>src/wiki_tools.py</code></summary>
        <pre class="highlight"><code class="language-python">def find_dependencies_recursively(title, site, dependencies=[], debug=False):
    """Finds all included templates, properties and categories within a wiki page

    Parameters
    ----------    
    title : str
        Title of the wiki page, e. g. User:Someone1234
    site : mwclient.client.Site
        Site object from mwclient lib    
    dependencies
        List of already found dependent titles
    debug : bool
        Whether to print debugging messages

    Returns
    -------
    dependencies : list
    """
    title = title.replace("{", "").replace("}", "")
    page = site.pages[title]
    content = page.text()
    new_dependencies = find_dependencies(content, debug)
    for dependency in new_dependencies:
        if dependency not in dependencies:  # for circular dependencies
            dependencies.append(dependency)
            if debug: print("Scan nested {}".format(dependency))
            find_dependencies_recursively(dependency, site, dependencies=dependencies, debug=debug)
    return dependencies</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="wiki_tools.get_wikitext_from_flat_content_dict" class="doc doc-heading">
<code class="highlight language-python">get_wikitext_from_flat_content_dict(d)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Create wiki source text from a flat python dict representing a wiki template</p>
<h4 id="wiki_tools.get_wikitext_from_flat_content_dict--parameters">Parameters</h4>

<details class="d-">
  <summary>dict</summary>
  <p>flat python dict
e.g.: {"HeaderTemplate": {"param": "value"}}</p>
</details>      <h4 id="wiki_tools.get_wikitext_from_flat_content_dict--returns">Returns</h4>

<details class="wt-">
  <summary>str</summary>
  <p>wiki text</p>
</details>
      <details class="quote">
        <summary>Source code in <code>src/wiki_tools.py</code></summary>
        <pre class="highlight"><code class="language-python">def get_wikitext_from_flat_content_dict(d: dict):
    """Create wiki source text from a flat python dict representing a wiki template

    Parameters
    ----------
    d : dict
        flat python dict
        e.g.: {"HeaderTemplate": {"param": "value"}}

    Returns
    -------
    wt : str
        wiki text
    """
    wt = ""
    for key, value in d.items():
        #print("key: {}, valuetype: {}, value: {}".format(key, type(value), "")) 
        if isinstance(value,dict): 
            #print("dict")
            wt += "{{" + key
            wt += get_wikitext_from_flat_content_dict(value)
            wt += "\n}}"
        elif isinstance(value,list): 
            #print("list")
            wt += "\n|{}=".format(key)
            string_index = 0
            for index, element in enumerate(value):
                if isinstance(element,dict): 
                    wt += get_wikitext_from_flat_content_dict(element)
                    #wt += "\n{{" + element
                    #wt += get_wikitext_from_dict(element)
                    #wt += "\n}}"  
                else:
                    if (string_index != index): print(f"Warning: template param '{key}' has mixed template/string values: {value}")
                    if string_index &gt; 0 and element and not element.strip().isspace(): wt += ";"
                    wt += element
                    string_index +=1
        else: 
            #print("literal")
            wt += "\n|{}={}".format(key, value)
    return wt</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="wiki_tools.get_wikitext_from_flat_content_structure" class="doc doc-heading">
<code class="highlight language-python">get_wikitext_from_flat_content_structure(content)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Create wiki source text from the content list (aka 'flat_content_structure' = 'wikiJson') of the page</p>
<h4 id="wiki_tools.get_wikitext_from_flat_content_structure--parameters">Parameters</h4>

<details class="content-">
  <summary>list</summary>
  <p>content list, mixed objects (templates) and free text (aka 'flat_content_structure' = 'wikiJson')
e.g.: [{"HeaderTemplate": {"param": "value"}}, "freetext", {"FooterTemplate": {"param2": "value"}}]</p>
</details>      <h4 id="wiki_tools.get_wikitext_from_flat_content_structure--returns">Returns</h4>
<p>wt : wiki text</p>

      <details class="quote">
        <summary>Source code in <code>src/wiki_tools.py</code></summary>
        <pre class="highlight"><code class="language-python">def get_wikitext_from_flat_content_structure(content):
    """Create wiki source text from the content list (aka 'flat_content_structure' = 'wikiJson') of the page

    Parameters
    ----------
    content : list
        content list, mixed objects (templates) and free text (aka 'flat_content_structure' = 'wikiJson')
        e.g.: [{"HeaderTemplate": {"param": "value"}}, "freetext", {"FooterTemplate": {"param2": "value"}}]

    Returns
    -------
    wt : wiki text
    """
    wt = ""
    for content_element in content:
        if isinstance(content_element,dict): 
            wt += get_wikitext_from_flat_content_dict(content_element)
        elif isinstance(content_element,str): wt += content_element#"\n" + content_element
        else: print("Error: content element is not dict or string: {}".format(content_element))
    return wt</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="wiki_tools.merge_wiki_page_text" class="doc doc-heading">
<code class="highlight language-python">merge_wiki_page_text(text1, text2, template_name, subtemplate_param='', subtemplate_name='')</code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Not fully tested function!</p>
<h4 id="wiki_tools.merge_wiki_page_text--parameters">Parameters</h4>
<p>text1
text2
template_name
subtemplate_param
subtemplate_name</p>
<h4 id="wiki_tools.merge_wiki_page_text--returns">Returns</h4>
<p>non_empty_lines : str</p>

      <details class="quote">
        <summary>Source code in <code>src/wiki_tools.py</code></summary>
        <pre class="highlight"><code class="language-python">def merge_wiki_page_text(text1, text2, template_name, subtemplate_param="", subtemplate_name=""):
    """Not fully tested function!

    Parameters
    ----------
    text1
    text2
    template_name
    subtemplate_param
    subtemplate_name

    Returns
    -------
    non_empty_lines : str
    """

    if text1 == text2: return text1
    if text1 == "": return text2
    if text2 == "": return text1
    code1 = mwparserfromhell.parse(text1)
    code2 = mwparserfromhell.parse(text2)
    r1 = []
    r2 = []
    for template in code1.filter_templates(recursive=True):
        if template.name.matches(template_name): t1 = template
        if template.name.matches(subtemplate_name): r1.append(template)
    for template in code2.filter_templates(recursive=True):
        if template.name.matches(template_name): t2 = template
        if template.name.matches(subtemplate_name): r2.append(template)
    # print("T1: " + str(t1))
    # print("T2: " + str(t2))
    for p in t2.params:
        if not t1.has(p.name):
            t1.add(p.name, p.value)
    if subtemplate_param != "":
        t1.remove(subtemplate_param)
        for rel2 in r2:
            exists = False
            for rel1 in r1:
                all_params_equal = True
                for p in rel2.params:
                    if rel1.has(p.name):
                        if not rel1.get(p.name).value.matches(rel2.get(p.name).value): all_params_equal = False
                        # print("Compare {}:{} with :{} -&gt; res={}".format(p.name, rel1.get(p.name).value,rel2.get(p.name).value,
                        #                                                rel1.get(p.name).value.matches(rel2.get(p.name).value)))
                    else:
                        all_params_equal = False
                if all_params_equal: exists = True
            if not exists: r1.append(rel2)
        r1string = ""
        for rel1 in r1:
            r1string += "\r\n   " + str(rel1)
        t1.add(subtemplate_param, r1string)
    # print("Tmerged: " + str(t1))
    non_empty_lines = "\n".join([ll.rstrip() for ll in str(t1).splitlines() if ll.strip()])
    return non_empty_lines</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="wiki_tools.prefix_search" class="doc doc-heading">
<code class="highlight language-python">prefix_search(site, text)</code>

</h2>


  <div class="doc doc-contents ">
  
      <h4 id="wiki_tools.prefix_search--parameters">Parameters</h4>

<details class="site-">
  <summary>mwclient.client.Site</summary>
  <p>Site object from mwclient lib</p>
</details>      <p>text : str</p>
<h4 id="wiki_tools.prefix_search--returns">Returns</h4>
<p>page_list : list</p>

      <details class="quote">
        <summary>Source code in <code>src/wiki_tools.py</code></summary>
        <pre class="highlight"><code class="language-python">def prefix_search(site, text):
    """

    Parameters
    ----------
    site : mwclient.client.Site
        Site object from mwclient lib
    text : str

    Returns
    -------
    page_list : list
    """
    page_list = []
    result = site.api('query', list="prefixsearch", pssearch=text, pslimit=1000, format='json')
    if len(result['query']['prefixsearch']) == 0:
        print('No results')
    else:
        for page in result['query']['prefixsearch']:
            title = page['title']
            print(title)
            page_list.append(title)
    return page_list</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="wiki_tools.schemaJson2WikiJson" class="doc doc-heading">
<code class="highlight language-python">schemaJson2WikiJson(schemaJson, isRoot=True)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Create content representation of a page (aka 'flat_content_structure' = 'wikiJson')  from the osl schema-compatible json</p>
<h4 id="wiki_tools.schemaJson2WikiJson--parameters">Parameters</h4>

<details class="schemajson-">
  <summary>dict</summary>
  <p>schema-compatible json
e.g.: {osl_template: "HeaderTemplate", "param": "value", "osl_wikitext": "freetext", "osl_footer": {"osl_template": "FooterTemplate", "param2": "value2"}}</p>
</details>
<details class="isroot">
  <summary>boolean</summary>
  <p>indicates first call in recursion</p>
</details>      <h4 id="wiki_tools.schemaJson2WikiJson--returns">Returns</h4>

<details class="wikijson-">
  <summary>list</summary>
  <p>content list, mixed objects (templates) and free text (aka 'flat_content_structure' = 'wikiJson') 
e.g.: [{"HeaderTemplate": {"param": "value"}}, "freetext", {"FooterTemplate": {"param2": "value"}}]</p>
</details>
      <details class="quote">
        <summary>Source code in <code>src/wiki_tools.py</code></summary>
        <pre class="highlight"><code class="language-python">def schemaJson2WikiJson(schemaJson, isRoot = True):
    """Create content representation of a page (aka 'flat_content_structure' = 'wikiJson')  from the osl schema-compatible json

    Parameters
    ----------
    schemaJson : dict
        schema-compatible json
        e.g.: {osl_template: "HeaderTemplate", "param": "value", "osl_wikitext": "freetext", "osl_footer": {"osl_template": "FooterTemplate", "param2": "value2"}}

    isRoot: boolean
        indicates first call in recursion

    Returns
    -------
    wikiJson : list
        content list, mixed objects (templates) and free text (aka 'flat_content_structure' = 'wikiJson') 
        e.g.: [{"HeaderTemplate": {"param": "value"}}, "freetext", {"FooterTemplate": {"param2": "value"}}]
    """
    wikiJson = [{}, "", {}]; #header, freetext, footer
    template = ""
    footer_template = ""
    if 'osl_template' in schemaJson:
        template = schemaJson['osl_template']
        wikiJson[0][template] = {}
    else:
        print("Error: Mandatory property 'osl_template' not found in schemaJson", schemaJson)
        return

    if 'osl_wikitext' in schemaJson: wikiJson[1] = schemaJson['osl_wikitext']
    if 'osl_footer' in schemaJson:
        wikiJson[2] = schemaJson2WikiJson(schemaJson['osl_footer'], False)[0]
        footer_template = schemaJson['osl_footer']['osl_template']
        wikiJson[2][footer_template]['extensions'] = []

    for key in schemaJson:
        if key.startswith('_') or key.startswith('osl_template') or key.startswith('osl_wikitext') or key.startswith('osl_footer'): continue #exclude private and reserved keywords
        if schemaJson[key] == None: continue
        if isinstance(schemaJson[key], list):
            wikiJson[0][template][key] = []
            for subSchemaJson in schemaJson[key]:
                subWikiJson = schemaJson2WikiJson(subSchemaJson, False)
                wikiJson[0][template][key].append(subWikiJson[0])
                if (key == "extensions"):
                    wikiJson[2][footer_template]['extensions'].append(subWikiJson[2])

        elif isinstance(schemaJson[key], dict):
            subWikiJson = schemaJson2WikiJson(subSchemaJson, False)
            wikiJson[0][template][key] = subWikiJson[0]
        else:
            wikiJson[0][template][key] = schemaJson[key]

    return wikiJson</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="wiki_tools.search_redirection_sources" class="doc doc-heading">
<code class="highlight language-python">search_redirection_sources(site, target_title, debug=False)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Returns a list of pages redirecting to the page with target_title per #REDIRECT [[target]] syntax</p>
<h4 id="wiki_tools.search_redirection_sources--parameters">Parameters</h4>

<details class="site-">
  <summary>mwclient.client.Site</summary>
  <p>Site object from mwclient lib</p>
</details>
<details class="target_title-">
  <summary>str</summary>
  <p>Title of the target wiki page</p>
</details>      <h4 id="wiki_tools.search_redirection_sources--returns">Returns</h4>
<p>page_list : list of pages redirecting to the page with target_title</p>

      <details class="quote">
        <summary>Source code in <code>src/wiki_tools.py</code></summary>
        <pre class="highlight"><code class="language-python">def search_redirection_sources(site, target_title, debug = False):
    """Returns a list of pages redirecting to the page with target_title per #REDIRECT [[target]] syntax

    Parameters
    ----------
    site : mwclient.client.Site
        Site object from mwclient lib
    target_title : str
        Title of the target wiki page

    Returns
    -------
    page_list : list of pages redirecting to the page with target_title
    """
    page_list = []
    result = site.api('query', titles=target_title, prop='redirects', format='json')
    if len(result['query']['pages'])==0:
        if (debug): print('No results')
    else:
        for page in result['query']['pages']:
            if not 'redirects' in result['query']['pages'][page]: 
                if (debug): print('No results')
            else:
                for redirecting_source in result['query']['pages'][page]['redirects']:
                    title = redirecting_source['title']
                    page_list.append(title)
    return page_list</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="wiki_tools.search_wiki_page" class="doc doc-heading">
<code class="highlight language-python">search_wiki_page(title, site)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Adds exact match functionality with ignore-case on top of the prefix_search()'s functionality</p>
<h4 id="wiki_tools.search_wiki_page--parameters">Parameters</h4>

<details class="title-">
  <summary>str</summary>
  <p>Title of the wiki page, e. g. User:Someone1234</p>
</details>
<details class="site-">
  <summary>mwclient.client.Site</summary>
  <p>Site object from mwclient lib</p>
</details>      <h4 id="wiki_tools.search_wiki_page--returns">Returns</h4>
<p>result_dict : dict</p>

      <details class="quote">
        <summary>Source code in <code>src/wiki_tools.py</code></summary>
        <pre class="highlight"><code class="language-python">def search_wiki_page(title, site):
    """Adds exact match functionality with ignore-case on top of the prefix_search()'s functionality

    Parameters
    ----------
    title : str
        Title of the wiki page, e. g. User:Someone1234
    site : mwclient.client.Site
        Site object from mwclient lib

    Returns
    -------
    result_dict : dict
    """
    result = site.api('query', list="prefixsearch", pssearch=title, pslimit=1000, format='json')
    if len(result['query']['prefixsearch']) == 0:
        return {"Result": False, "List": list()}
    else:
        exact_match = False
        page_title_list = list()
        for page in result['query']['prefixsearch']:
            page_title = page['title']
            page_title_list.append(page_title)
            if page_title.lower() == title.lower():
                exact_match = True
        result_dict = {"Result": True, "List": page_title_list, "Exact match": exact_match}
        return result_dict</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="wiki_tools.semantic_search" class="doc doc-heading">
<code class="highlight language-python">semantic_search(site, query)</code>

</h2>


  <div class="doc doc-contents ">
  
      <h4 id="wiki_tools.semantic_search--parameters">Parameters</h4>

<details class="site-">
  <summary>mwclient.client.Site</summary>
  <p>Site object from mwclient lib</p>
</details>      <p>query</p>
<h4 id="wiki_tools.semantic_search--returns">Returns</h4>
<p>page_list : list</p>

      <details class="quote">
        <summary>Source code in <code>src/wiki_tools.py</code></summary>
        <pre class="highlight"><code class="language-python">def semantic_search(site, query):
    """

    Parameters
    ----------
    site : mwclient.client.Site
        Site object from mwclient lib
    query

    Returns
    -------
    page_list : list
    """
    page_list = []
    query += "|limit=1000"
    result = site.api('ask', query=query, format='json')
    if len(result['query']['results']) == 0:
        print("Query '{}' returned no results".format(query))
    else:
        print("Query '{}' returned {} results".format(query, len(result['query']['results'])))
        for page in result['query']['results'].values():
            # why do we do the following?
            if 'printouts' in page:
                title = page['fulltext']
                if '#' not in title:
                    print(title)
                    # original position of "page_list.append(title)" line
            page_list.append(title)
    return page_list</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="wiki_tools.update_template_within_wikitext" class="doc doc-heading">
<code class="highlight language-python">update_template_within_wikitext(text, template_text, delete=False, remove_empty_lines=False, overwrite_with_empty=False)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Updates the template parameters in an existing wiki <text> with a provided new <template_text></p>
<h4 id="wiki_tools.update_template_within_wikitext--parameters">Parameters</h4>

<details class="text-">
  <summary>str</summary>
  <p>The existing text</p>
</details>
<details class="template_text-">
  <summary>str</summary>
  <p>The template text with new data</p>
</details>
<details class="delete-">
  <summary>bool</summary>
  <p>If true, params not defined in <template_text> get removed from <text></p>
</details>
<details class="remove_empty_lines-">
  <summary>bool</summary>
  <p>If true, function will cleanup empty lines within the template code created by the underlying mwparserfromhell
lib (wanted), but also within the wiki text around it (unwanted)</p>
</details>
<details class="overwrite_with_empty-">
  <summary>bool</summary>
  <p>If true, parameters in the existing tempalte will be overwritten even if the parameter value in the 
template_text is empty</p>
</details>      <h4 id="wiki_tools.update_template_within_wikitext--returns">Returns</h4>
<p>new_text : str</p>

      <details class="quote">
        <summary>Source code in <code>src/wiki_tools.py</code></summary>
        <pre class="highlight"><code class="language-python">def update_template_within_wikitext(text, template_text, delete=False, remove_empty_lines=False, 
                                    overwrite_with_empty=False):
    """Updates the template parameters in an existing wiki &lt;text&gt; with a provided new &lt;template_text&gt;

    Parameters
    ----------
    text : str
        The existing text
    template_text : str
        The template text with new data
    delete : bool
        If true, params not defined in &lt;template_text&gt; get removed from &lt;text&gt;
    remove_empty_lines : bool
        If true, function will cleanup empty lines within the template code created by the underlying mwparserfromhell
        lib (wanted), but also within the wiki text around it (unwanted)
    overwrite_with_empty : bool
        If true, parameters in the existing tempalte will be overwritten even if the parameter value in the 
        template_text is empty

    Returns
    -------
    new_text : str
    """
    if template_text == text: return template_text
    if template_text == "": return text
    if text == "": return template_text
    new_code = mwparserfromhell.parse(template_text)
    new_template = new_code.filter_templates()[0]
    existing_code = mwparserfromhell.parse(text)
    template_names_matched = False 
    for template in existing_code.filter_templates(recursive=True):
        if template.name.matches(new_template.name):
            existing_template = template
            template_names_matched = True
            break
    if template_names_matched:
        for p in new_template.params:
            if existing_template.has(p.name):
                if p.value != "" or overwrite_with_empty:
                    existing_template.get(p.name).value = p.value
            else:
                existing_template.add(p.name, p.value)
        if delete:
            for p in existing_template.params:
                if not new_template.has(p.name):
                    existing_template.remove(p)
    else:  # the original text did not contain a matching template
        # options: 1) include the new template
        # 2) replace the existing template - but what if multiple tempaltes exist on that page?
        pass
    # print("Tmerged: \n" + str(existing_template))
    # print("Text merged: " + str(existing_code))
    new_text = str(existing_code)
    # this will cleanup empty lines within the template code (wanted), but also within the wiki text around it (unwanted)
    if remove_empty_lines: new_text = "\n".join([ll.rstrip() for ll in str(new_text).splitlines() if ll.strip()])
    return new_text</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="wiki_tools.wikiJson2SchemaJson" class="doc doc-heading">
<code class="highlight language-python">wikiJson2SchemaJson(wikiJson)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Create osl schema-compatible json from the content representation of a page (aka 'flat_content_structure' = 'wikiJson') </p>
<h4 id="wiki_tools.wikiJson2SchemaJson--parameters">Parameters</h4>

<details class="wikijson-">
  <summary>list</summary>
  <p>content list, mixed objects (templates) and free text (aka 'flat_content_structure' = 'wikiJson') 
e.g.: [{"HeaderTemplate": {"param": "value"}}, "freetext", {"FooterTemplate": {"param2": "value"}}]</p>
</details>      <h4 id="wiki_tools.wikiJson2SchemaJson--returns">Returns</h4>

<details class="schemajson-">
  <summary>dict</summary>
  <p>schema-compatible json
e.g.: {osl_template: "HeaderTemplate", "param": "value", "osl_wikitext": "freetext", "osl_footer": {"osl_template": "FooterTemplate", "param2": "value2"}}</p>
</details>
      <details class="quote">
        <summary>Source code in <code>src/wiki_tools.py</code></summary>
        <pre class="highlight"><code class="language-python">def wikiJson2SchemaJson(wikiJson):
    """Create osl schema-compatible json from the content representation of a page (aka 'flat_content_structure' = 'wikiJson') 

    Parameters
    ----------
    wikiJson : list
        content list, mixed objects (templates) and free text (aka 'flat_content_structure' = 'wikiJson') 
        e.g.: [{"HeaderTemplate": {"param": "value"}}, "freetext", {"FooterTemplate": {"param2": "value"}}]

    Returns
    -------
    schemaJson : dict
        schema-compatible json
        e.g.: {osl_template: "HeaderTemplate", "param": "value", "osl_wikitext": "freetext", "osl_footer": {"osl_template": "FooterTemplate", "param2": "value2"}}
    """
    schemaJson = {}
    if not isinstance(wikiJson[0], dict) or not isinstance(wikiJson[1],str) or not isinstance(wikiJson[2], dict):
        print("Error: Invalid wikiJson:", wikiJson)
        return schemaJson

    schemaJson = {}

    schemaJson = wikiJson2SchemaJsonRecursion(wikiJson[0], wikiJson[2])
    schemaJson["osl_wikitext"] = wikiJson[1]
    return schemaJson</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="wiki_tools.wikiJson2SchemaJsonRecursion" class="doc doc-heading">
<code class="highlight language-python">wikiJson2SchemaJsonRecursion(wikiJson, footerWikiJson=None)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p>internal recursion function of wikiJson2SchemaJson()</p>
<h4 id="wiki_tools.wikiJson2SchemaJsonRecursion--parameters">Parameters</h4>

<details class="wikijson-">
  <summary>list</summary>
  <p>wiki template representation 
e.g.: {"HeaderTemplate": {"param": "value"}}</p>
</details>
<details class="footerwikijson-">
  <summary>list</summary>
  <p>wiki footer template representation 
e.g.: {"FooterTemplate": {"param2": "value2"}}</p>
</details>      <h4 id="wiki_tools.wikiJson2SchemaJsonRecursion--returns">Returns</h4>

<details class="schemajson-">
  <summary>dict</summary>
  <p>schema-compatible json
e.g.: {osl_template: "HeaderTemplate", "param": "value", "osl_footer": {"osl_template": "FooterTemplate", "param2": "value2"}}</p>
</details>
      <details class="quote">
        <summary>Source code in <code>src/wiki_tools.py</code></summary>
        <pre class="highlight"><code class="language-python">def wikiJson2SchemaJsonRecursion(wikiJson, footerWikiJson = None):
    """internal recursion function of wikiJson2SchemaJson()

    Parameters
    ----------
    wikiJson : list
        wiki template representation 
        e.g.: {"HeaderTemplate": {"param": "value"}}

    footerWikiJson : list
        wiki footer template representation 
        e.g.: {"FooterTemplate": {"param2": "value2"}}

    Returns
    -------
    schemaJson : dict
        schema-compatible json
        e.g.: {osl_template: "HeaderTemplate", "param": "value", "osl_footer": {"osl_template": "FooterTemplate", "param2": "value2"}}
    """
    schemaJson = {}
    if footerWikiJson != None:
        schemaJson['osl_footer'] = wikiJson2SchemaJsonRecursion(footerWikiJson)

    for key in wikiJson:
        value = wikiJson[key]
        if isinstance(value,list): 
            schemaJson[key] = []
            for index, element in enumerate(value):
                element = value[index]
                if isinstance(element,dict): 
                    if key == "extensions":
                        if footerWikiJson != None: #we asume that every extension provides also a footer template
                            nextFooter = footerWikiJson[schemaJson['osl_footer']['osl_template']]['extensions'][index]
                            schemaJson[key].append(wikiJson2SchemaJsonRecursion(element, nextFooter))
                    else: schemaJson[key].append(wikiJson2SchemaJsonRecursion(element))
                else:
                    schemaJson[key].append(element)

        elif isinstance(value,dict): 
            schemaJson = wikiJson2SchemaJsonRecursion(value, footerWikiJson)
            schemaJson['osl_template'] = key
        else:
            schemaJson[key] = value

    for key in list(schemaJson.keys()):
        if schemaJson[key] == "" and key == 'extensions': del schemaJson[key]
        elif isinstance(schemaJson[key], list): #wikiJson defaults are lists, even for single or empty values
            if len(schemaJson[key]) == 0: del schemaJson[key]
            #elif len(schemaJson[key]) == 1: schemaJson[key] = schemaJson[key][0]

    return schemaJson</code></pre>
      </details>
  </div>

</div>



  </div>

  </div>

</div>

<div class="doc doc-object doc-class">


<a id="osl.OSL"></a>
  <div class="doc doc-contents first">
      <p class="doc doc-class-bases">
        Bases: <code><span title="pydantic.BaseModel">BaseModel</span></code></p>



        <details class="quote">
          <summary>Source code in <code>src/osl.py</code></summary>
          <pre class="highlight"><code class="language-python">class OSL(BaseModel):
    uuid: str = "2ea5b605-c91f-4e5a-9559-3dff79fdd4a5"
    _protected_keywords = ('_osl_template', '_osl_footer') #private properties included in model export
    class Config:
        arbitrary_types_allowed = True #neccessary to allow e.g. np.array as type
    site: WtSite

    def sync(self, entity: AbstractEntity):
        if not entity.title: entity.title = entity.ns + ":OSL" + entity.uuid.replace('-', '');
        wtpage = self.site.get_WtPage(entity.title)

        pprint(wtpage)

    def fetch_schema(self, schema_title = "JsonSchema:KB/Entity", root = True):
        schema_name = schema_title.split(':')[-1]
        page = self.site.get_WtPage(schema_title)
        schema = json.loads(page._content.replace("$ref", "dollarref")) # '$' is a special char for root object in jsonpath
        #print(schema)

        jsonpath_expr = parse("$..dollarref")
        for match in jsonpath_expr.find(schema):
            #value = "https://" + self.site._site.host + match.value
            ref_schema_title = match.value.replace("/wiki/","").split('?')[0]
            ref_schema_name = ref_schema_title.split(':')[-1] + ".json"
            value = ""
            for i in range (0, ref_schema_name.count('/')): value += "../" #created relative path to top-level schema dir
            value += ref_schema_name #create a reference to a local file
            match.full_path.update_or_create(schema, value)
            #print(f"replace {match.value} with {value}")
            if (ref_schema_title != schema_title): #prevent recursion in case of self references
                 self.fetch_schema(schema_title = ref_schema_title, root = False) #resolve references recursive

        schema_path = "src/model/" + schema_name + ".json"
        os.makedirs(os.path.dirname(schema_path), exist_ok=True)
        with open(schema_path, 'w', encoding='utf-8') as f:
            schema_str = json.dumps(schema, ensure_ascii=False, indent=4).replace("dollarref", "$ref")
            #print(schema_str)
            f.write(schema_str)

        model_path = schema_path.replace(".json", ".py")
        if (root): 
            os.system(f"datamodel-codegen  --input {schema_path} --input-file-type jsonschema --output {model_path} \
                --base-class OslBaseModel \
                --use-default \
                --enum-field-as-literal one \
                --use-title-as-name \
                --use-schema-description \
                --use-field-description \
            ")
            #see https://koxudaxi.github.io/datamodel-code-generator/
            #--base-class OslBaseModel: use a custom base class
            #--custom-template-dir src/model/template_data/ 
            #--extra-template-data src/model/template_data/extra.json 
            #--use-default: Use default value even if a field is required
            #--enum-field-as-literal one: for static properties like osl_template
            #--use-schema-description: Use schema description to populate class docstring
            #--use-field-description: Use schema description to populate field docstring
            #--use-title-as-name: use titles as class names of models, e. g. for the footer templates

            #this is dirty, but required for autocompletion: https://stackoverflow.com/questions/62884543/pydantic-autocompletion-in-vs-code
            #idealy solved by custom templates in the future: https://github.com/koxudaxi/datamodel-code-generator/issues/860

            with open (model_path, 'r' ) as f:
                content = f.read()
                header = (  "from typing import TYPE_CHECKING\n"
                            "\n"
                            "if TYPE_CHECKING:\n"
                            "    from dataclasses import dataclass as _basemodel_decorator\n"
                            "else:\n"
                            "    _basemodel_decorator = lambda x: x\n"
                            "\n"
                        )
                header += (
                    "\nclass OslBaseModel(BaseModel):\n"
                    "    def full_dict(self, **kwargs): #extent BaseClass export function\n"
                    "        d = super().dict(**kwargs)\n"
                    "        for key in " + str(self._protected_keywords) + ":\n"
                    "            if hasattr(self, key): d[key] = getattr(self, key) #include selected private properites. note: private properties are not considered as discriminator \n"
                    "        return d\n"
                )
                content = re.sub(r"(import OslBaseModel)", "from pydantic import BaseModel", content, 1) #remove import statement
                content = re.sub(r"(class\s*\S*\s*\(\s*OslBaseModel\s*\)\s*:.*\n)", header + r"\n\n\n\1", content, 1) #replace first match
                content = re.sub(r"(class\s*\S*\s*\(\s*OslBaseModel\s*\)\s*:.*\n)", r"@_basemodel_decorator\n\1", content)
            with open (model_path, 'w' ) as f:    
                f.write(content)

            importlib.reload(model) #reload the updated module

    def load_entity(self, entity_title):
        page = self.site.get_WtPage(entity_title)
        json = wt.wikiJson2SchemaJson(page._dict)
        #pprint(json)
        try:
            model.Device
        except AttributeError:
            print("Device not defined")
        else:
            print("Device defined")
        entity = model.Entity(**json)
        return entity

    def store_entity(self, entity_title, entity):
        page = self.site.get_WtPage(entity_title)
        schema_json = entity.full_dict()
        #print(json)
        wiki_json = wt.schemaJson2WikiJson(schema_json)
        #print(wiki_json)
        page._dict = wiki_json
        page.update_content()
        page.edit()</code></pre>
        </details>

  

  <div class="doc doc-children">











  </div>

  </div>

</div>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href=".." class="btn btn-neutral float-left" title="Home"><span class="icon icon-circle-arrow-left"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href=".." style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
