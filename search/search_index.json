{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home OpenSemanticLab Python Package Source: https://github.com/OpenSemanticLab/Tools","title":"Home"},{"location":"#home","text":"OpenSemanticLab Python Package Source: https://github.com/OpenSemanticLab/Tools","title":"Home"},{"location":"model/","text":"OpenSematicLab Model l Bases: BaseModel Source code in model/KB/Entity.py 22 23 24 25 26 27 28 29 30 31 32 33 34 class Entity ( BaseModel ): osl_template : Optional [ str ] = 'OslTemplate:KB/Entity' osl_template_label : Optional [ str ] = 'Entity' label : Optional [ Union [ str , List [ str ]]] = Field ( None , title = 'Label' ) \"\"\" Human readable name \"\"\" label_lang_code : Optional [ LangCode ] = Field ( 'en' , title = 'Lang code' ) extensions : Optional [ List [ Any ]] = Field ( None , title = 'Extensions' ) osl_wikitext : Optional [ str ] = '=Details= \\n ' osl_footer : Optional [ KBEntityFooter ] = Field ( { 'osl_template' : 'OslTemplate:KB/Entity/Footer' }, title = 'KB/Entity/Footer' ) label : Optional [ Union [ str , List [ str ]]] = Field ( None , title = 'Label' ) class-attribute Human readable name","title":"Model"},{"location":"model/#model.KB.Entity.Entity.label","text":"Human readable name","title":"label"},{"location":"osl/","text":"OpenSematicLab Class Bases: BaseModel OSL Class Source code in src/osl.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 class OSL ( BaseModel ): \"\"\"OSL Class \"\"\" uuid : str = \"2ea5b605-c91f-4e5a-9559-3dff79fdd4a5\" _protected_keywords = ( '_osl_template' , '_osl_footer' ) #private properties included in model export class Config : arbitrary_types_allowed = True #neccessary to allow e.g. np.array as type site : WtSite def sync ( self , entity : AbstractEntity ): if not entity . title : entity . title = entity . ns + \":OSL\" + entity . uuid . replace ( '-' , '' ); wtpage = self . site . get_WtPage ( entity . title ) pprint ( wtpage ) @model . _basemodel_decorator class SchemaRegistration ( BaseModel ): \"\"\" the model class \"\"\" model_cls : ModelMetaclass \"\"\" the name of the schema \"\"\" schema_name : str schema_bases : List [ str ] = [ \"KB/Entity\" ] def register_schema ( self , schema_registration : SchemaRegistration ): \"\"\"registers a new or updated schema in OSL Parameters ---------- schema_registration see SchemaRegistration \"\"\" page = self . site . get_WtPage ( \"JsonSchema:\" + schema_registration . schema_name ) schema = json . loads ( schema_registration . model_cls . schema_json ( indent = 4 ) . replace ( \"$ref\" , \"dollarref\" )) jsonpath_expr = parse ( '$..allOf' ) #replace local definitions (#/definitions/...) with embedded definitions to prevent resolve errors in json-editor for match in jsonpath_expr . find ( schema ): result_array = [] for subschema in match . value : pprint ( subschema ) value = subschema [ 'dollarref' ] if value . startswith ( '#' ): definition_jsonpath_expr = parse ( value . replace ( '#' , '$' ) . replace ( '/' , '.' )) for def_match in definition_jsonpath_expr . find ( schema ): pprint ( def_match . value ) result_array . append ( def_match . value ) else : result_array . append ( subschema ) match . full_path . update_or_create ( schema , result_array ) if 'definitions' in schema : del schema [ 'definitions' ] #replace 'osl_footer': {'allOf': [{...}]} with 'osl_footer': {...} if 'allOf' in schema [ 'properties' ][ 'osl_footer' ]: schema [ 'properties' ][ 'osl_footer' ] = schema [ 'properties' ][ 'osl_footer' ][ 'allOf' ][ 0 ] #directy attach single definition schema [ 'properties' ][ 'osl_footer' ][ 'options' ] = { \"hidden\" : True } #don't show this field in the json-editor if not 'required' in schema [ 'properties' ][ 'osl_footer' ]: schema [ 'properties' ][ 'osl_footer' ][ 'required' ] = [] #add required property if missing schema [ 'properties' ][ 'osl_footer' ][ 'required' ] . extend ([ 'osl_template' ]) schema [ 'properties' ][ 'osl_template' ][ 'options' ] = { \"hidden\" : True } #don't show this field in the json-editor schema [ 'properties' ][ 'osl_template' ][ 'enum' ] = [ schema [ 'properties' ][ 'osl_template' ][ 'default' ]] #a single-value enum represents a constant / literal if not 'required' in schema : schema [ 'required' ] = [] #add required property if missing schema [ 'required' ] . extend ([ 'osl_template' , 'osl_footer' ]) pprint ( schema ) page . set_content ( json . dumps ( schema , indent = 4 ) . replace ( \"dollarref\" , \"$ref\" )) page . edit ( \"Create / update schema from pydantic BaseModel\" ) for base in schema_registration . schema_bases : page = self . site . get_WtPage ( \"JsonSchema:\" + base ) schema = json . loads ( page . get_content ()) refs = schema [ 'properties' ][ 'extensions' ][ 'items' ][ 'oneOf' ] #pprint(refs) schema_url = '/wiki/JsonSchema:' + schema_registration . schema_name + '?action=raw' missing = True for ref in refs : if ref [ '$ref' ] == schema_url : missing = False print ( missing ) if missing : refs . append ({ '$ref' : schema_url }) #pprint(schema) page . set_content ( json . dumps ( schema , indent = 4 )) page . edit ( \"add extension schema \" + schema_registration . schema_name ) class FetchSchemaMode ( Enum ): append = \"append\" #append to the current model replace = \"replace\" #replace the current model @model . _basemodel_decorator class FetchSchemaParam ( BaseModel ): schema_title : Optional [ str ] = \"JsonSchema:KB/Entity\" root : Optional [ bool ] = True mode : Optional [ str ] = 'replace' #type 'FetchSchemaMode' requires: 'from __future__ import annotations' def fetch_schema ( self , fetchSchemaParam : FetchSchemaParam ): schema_title = fetchSchemaParam . schema_title root = fetchSchemaParam . root schema_name = schema_title . split ( ':' )[ - 1 ] page = self . site . get_WtPage ( schema_title ) schema = json . loads ( page . _content . replace ( \"$ref\" , \"dollarref\" )) # '$' is a special char for root object in jsonpath print ( f \"Fetch { schema_title } \" ) jsonpath_expr = parse ( \"$..dollarref\" ) for match in jsonpath_expr . find ( schema ): #value = \"https://\" + self.site._site.host + match.value if match . value . startswith ( '#' ): continue #skip self references ref_schema_title = match . value . replace ( \"/wiki/\" , \"\" ) . split ( '?' )[ 0 ] ref_schema_name = ref_schema_title . split ( ':' )[ - 1 ] + \".json\" value = \"\" for i in range ( 0 , schema_name . count ( '/' )): value += \"../\" #created relative path to top-level schema dir value += ref_schema_name #create a reference to a local file match . full_path . update_or_create ( schema , value ) #print(f\"replace {match.value} with {value}\") if ( ref_schema_title != schema_title ): #prevent recursion in case of self references self . fetch_schema ( OSL . FetchSchemaParam ( schema_title = ref_schema_title , root = False )) #resolve references recursive schema_path = \"src/model/\" + schema_name + \".json\" os . makedirs ( os . path . dirname ( schema_path ), exist_ok = True ) with open ( schema_path , 'w' , encoding = 'utf-8' ) as f : schema_str = json . dumps ( schema , ensure_ascii = False , indent = 4 ) . replace ( \"dollarref\" , \"$ref\" ) #print(schema_str) f . write ( schema_str ) #result_model_path = schema_path.replace(\".json\", \".py\") result_model_path = \"src/model/KB/Entity.py\" temp_model_path = \"src/model/temp.py\" if ( root ): os . system ( f \"datamodel-codegen --input { schema_path } --input-file-type jsonschema --output { temp_model_path } \\ --base-class OslBaseModel \\ --use-default \\ --enum-field-as-literal one \\ --use-title-as-name \\ --use-schema-description \\ --use-field-description \\ \" ) #see https://koxudaxi.github.io/datamodel-code-generator/ #--base-class OslBaseModel: use a custom base class #--custom-template-dir src/model/template_data/ #--extra-template-data src/model/template_data/extra.json #--use-default: Use default value even if a field is required #--enum-field-as-literal one: for static properties like osl_template #--use-schema-description: Use schema description to populate class docstring #--use-field-description: Use schema description to populate field docstring #--use-title-as-name: use titles as class names of models, e. g. for the footer templates #this is dirty, but required for autocompletion: https://stackoverflow.com/questions/62884543/pydantic-autocompletion-in-vs-code #idealy solved by custom templates in the future: https://github.com/koxudaxi/datamodel-code-generator/issues/860 content = \"\" with open ( temp_model_path , 'r' ) as f : content = f . read () os . remove ( temp_model_path ) content = re . sub ( r \"(import OslBaseModel)\" , \"from pydantic import BaseModel\" , content , 1 ) #remove import statement if fetchSchemaParam . mode == 'replace' : header = ( \"from typing import TYPE_CHECKING \\n \" \" \\n \" \"if TYPE_CHECKING: \\n \" \" from dataclasses import dataclass as _basemodel_decorator \\n \" \"else: \\n \" \" _basemodel_decorator = lambda x: x \\n \" \" \\n \" ) header += ( \" \\n class OslBaseModel(BaseModel): \\n \" \" def full_dict(self, **kwargs): #extent BaseClass export function \\n \" \" d = super().dict(**kwargs) \\n \" \" for key in \" + str ( self . _protected_keywords ) + \": \\n \" \" if hasattr(self, key): d[key] = getattr(self, key) #include selected private properites. note: private properties are not considered as discriminator \\n \" \" return d \\n \" ) content = re . sub ( r \"(class\\s*\\S*\\s*\\(\\s*OslBaseModel\\s*\\)\\s*:.*\\n)\" , header + r \"\\n\\n\\n\\1\" , content , 1 ) #replace first match content = re . sub ( r \"(class\\s*\\S*\\s*\\(\\s*OslBaseModel\\s*\\)\\s*:.*\\n)\" , r \"@_basemodel_decorator\\n\\1\" , content ) with open ( result_model_path , 'w' ) as f : f . write ( content ) if fetchSchemaParam . mode == 'append' : org_content = \"\" with open ( result_model_path , 'r' ) as f : org_content = f . read () pattern = re . compile ( r \"class\\s*([\\S]*)\\s*\\(\\s*\\S*\\s*\\)\\s*:.*\\n\" ) #match class definition [\\s\\S]*(?:[^\\S\\n]*\\n){2,} for ( cls ) in re . findall ( pattern , org_content ): print ( cls ) content = re . sub ( r \"(class\\s*\" + cls + \"\\s*\\(\\s*\\S*\\s*\\)\\s*:.* \\n [\\s\\S]*?(?:[^\\S \\n ]* \\n ){2,})\" , \"\" , content , count = 1 ) #replace duplicated classes content = re . sub ( r \"(from __future__ import annotations)\" , \"\" , content , 1 ) #remove import statement #print(content) with open ( result_model_path , 'a' ) as f : f . write ( content ) importlib . reload ( model ) #reload the updated module def load_entity ( self , entity_title ): page = self . site . get_WtPage ( entity_title ) osl_schema = 'JsonSchema:KB/Entity' for key in page . _dict [ 0 ]: if 'osl_schema' in page . _dict [ 0 ][ key ]: osl_schema = page . _dict [ 0 ][ key ][ 'osl_schema' ] #cls = osl_schema.split(':')[1].split('/')[-1] #better use schema['title] schema_str = self . site . get_WtPage ( osl_schema ) . get_content () schema = json . loads ( schema_str . replace ( \"$ref\" , \"dollarref\" )) cls = schema [ 'title' ] #print(cls) full_schema_str = eval ( f \"model. { cls } .schema_json(indent=4)\" ) full_schema = json . loads ( full_schema_str . replace ( \"$ref\" , \"dollarref\" )) #print(full_schema_str) schema_json = wt . wikiJson2SchemaJson ( full_schema , page . _dict ) pprint ( schema_json ) try : model . Device except AttributeError : print ( \"Device not defined\" ) else : print ( \"Device defined\" ) entity = None #entity = model.Entity(**schema_json) #exec(f\"entity = model.{cls}(**schema_json)\") entity = eval ( f \"model. { cls } (**schema_json)\" ) return entity def store_entity ( self , entity_title , entity ): page = self . site . get_WtPage ( entity_title ) schema_json = entity . full_dict () #print(json) wiki_json = wt . schemaJson2WikiJson ( schema_json ) #print(wiki_json) page . _dict = wiki_json page . update_content () page . edit () SchemaRegistration Bases: BaseModel the model class Source code in src/osl.py 64 65 66 67 68 69 70 71 72 73 74 @model . _basemodel_decorator class SchemaRegistration ( BaseModel ): \"\"\" the model class \"\"\" model_cls : ModelMetaclass \"\"\" the name of the schema \"\"\" schema_name : str schema_bases : List [ str ] = [ \"KB/Entity\" ] model_cls : ModelMetaclass class-attribute the name of the schema register_schema ( schema_registration ) registers a new or updated schema in OSL Parameters: Name Type Description Default schema_registration SchemaRegistration see SchemaRegistration required Source code in src/osl.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def register_schema ( self , schema_registration : SchemaRegistration ): \"\"\"registers a new or updated schema in OSL Parameters ---------- schema_registration see SchemaRegistration \"\"\" page = self . site . get_WtPage ( \"JsonSchema:\" + schema_registration . schema_name ) schema = json . loads ( schema_registration . model_cls . schema_json ( indent = 4 ) . replace ( \"$ref\" , \"dollarref\" )) jsonpath_expr = parse ( '$..allOf' ) #replace local definitions (#/definitions/...) with embedded definitions to prevent resolve errors in json-editor for match in jsonpath_expr . find ( schema ): result_array = [] for subschema in match . value : pprint ( subschema ) value = subschema [ 'dollarref' ] if value . startswith ( '#' ): definition_jsonpath_expr = parse ( value . replace ( '#' , '$' ) . replace ( '/' , '.' )) for def_match in definition_jsonpath_expr . find ( schema ): pprint ( def_match . value ) result_array . append ( def_match . value ) else : result_array . append ( subschema ) match . full_path . update_or_create ( schema , result_array ) if 'definitions' in schema : del schema [ 'definitions' ] #replace 'osl_footer': {'allOf': [{...}]} with 'osl_footer': {...} if 'allOf' in schema [ 'properties' ][ 'osl_footer' ]: schema [ 'properties' ][ 'osl_footer' ] = schema [ 'properties' ][ 'osl_footer' ][ 'allOf' ][ 0 ] #directy attach single definition schema [ 'properties' ][ 'osl_footer' ][ 'options' ] = { \"hidden\" : True } #don't show this field in the json-editor if not 'required' in schema [ 'properties' ][ 'osl_footer' ]: schema [ 'properties' ][ 'osl_footer' ][ 'required' ] = [] #add required property if missing schema [ 'properties' ][ 'osl_footer' ][ 'required' ] . extend ([ 'osl_template' ]) schema [ 'properties' ][ 'osl_template' ][ 'options' ] = { \"hidden\" : True } #don't show this field in the json-editor schema [ 'properties' ][ 'osl_template' ][ 'enum' ] = [ schema [ 'properties' ][ 'osl_template' ][ 'default' ]] #a single-value enum represents a constant / literal if not 'required' in schema : schema [ 'required' ] = [] #add required property if missing schema [ 'required' ] . extend ([ 'osl_template' , 'osl_footer' ]) pprint ( schema ) page . set_content ( json . dumps ( schema , indent = 4 ) . replace ( \"dollarref\" , \"$ref\" )) page . edit ( \"Create / update schema from pydantic BaseModel\" ) for base in schema_registration . schema_bases : page = self . site . get_WtPage ( \"JsonSchema:\" + base ) schema = json . loads ( page . get_content ()) refs = schema [ 'properties' ][ 'extensions' ][ 'items' ][ 'oneOf' ] #pprint(refs) schema_url = '/wiki/JsonSchema:' + schema_registration . schema_name + '?action=raw' missing = True for ref in refs : if ref [ '$ref' ] == schema_url : missing = False print ( missing ) if missing : refs . append ({ '$ref' : schema_url }) #pprint(schema) page . set_content ( json . dumps ( schema , indent = 4 )) page . edit ( \"add extension schema \" + schema_registration . schema_name ) Bases: BaseModel the model class Source code in src/osl.py 64 65 66 67 68 69 70 71 72 73 74 @model . _basemodel_decorator class SchemaRegistration ( BaseModel ): \"\"\" the model class \"\"\" model_cls : ModelMetaclass \"\"\" the name of the schema \"\"\" schema_name : str schema_bases : List [ str ] = [ \"KB/Entity\" ] model_cls : ModelMetaclass class-attribute the name of the schema","title":"Osl"},{"location":"osl/#osl.OSL.SchemaRegistration","text":"Bases: BaseModel the model class Source code in src/osl.py 64 65 66 67 68 69 70 71 72 73 74 @model . _basemodel_decorator class SchemaRegistration ( BaseModel ): \"\"\" the model class \"\"\" model_cls : ModelMetaclass \"\"\" the name of the schema \"\"\" schema_name : str schema_bases : List [ str ] = [ \"KB/Entity\" ]","title":"SchemaRegistration"},{"location":"osl/#osl.OSL.SchemaRegistration.model_cls","text":"the name of the schema","title":"model_cls"},{"location":"osl/#osl.OSL.register_schema","text":"registers a new or updated schema in OSL Parameters: Name Type Description Default schema_registration SchemaRegistration see SchemaRegistration required Source code in src/osl.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def register_schema ( self , schema_registration : SchemaRegistration ): \"\"\"registers a new or updated schema in OSL Parameters ---------- schema_registration see SchemaRegistration \"\"\" page = self . site . get_WtPage ( \"JsonSchema:\" + schema_registration . schema_name ) schema = json . loads ( schema_registration . model_cls . schema_json ( indent = 4 ) . replace ( \"$ref\" , \"dollarref\" )) jsonpath_expr = parse ( '$..allOf' ) #replace local definitions (#/definitions/...) with embedded definitions to prevent resolve errors in json-editor for match in jsonpath_expr . find ( schema ): result_array = [] for subschema in match . value : pprint ( subschema ) value = subschema [ 'dollarref' ] if value . startswith ( '#' ): definition_jsonpath_expr = parse ( value . replace ( '#' , '$' ) . replace ( '/' , '.' )) for def_match in definition_jsonpath_expr . find ( schema ): pprint ( def_match . value ) result_array . append ( def_match . value ) else : result_array . append ( subschema ) match . full_path . update_or_create ( schema , result_array ) if 'definitions' in schema : del schema [ 'definitions' ] #replace 'osl_footer': {'allOf': [{...}]} with 'osl_footer': {...} if 'allOf' in schema [ 'properties' ][ 'osl_footer' ]: schema [ 'properties' ][ 'osl_footer' ] = schema [ 'properties' ][ 'osl_footer' ][ 'allOf' ][ 0 ] #directy attach single definition schema [ 'properties' ][ 'osl_footer' ][ 'options' ] = { \"hidden\" : True } #don't show this field in the json-editor if not 'required' in schema [ 'properties' ][ 'osl_footer' ]: schema [ 'properties' ][ 'osl_footer' ][ 'required' ] = [] #add required property if missing schema [ 'properties' ][ 'osl_footer' ][ 'required' ] . extend ([ 'osl_template' ]) schema [ 'properties' ][ 'osl_template' ][ 'options' ] = { \"hidden\" : True } #don't show this field in the json-editor schema [ 'properties' ][ 'osl_template' ][ 'enum' ] = [ schema [ 'properties' ][ 'osl_template' ][ 'default' ]] #a single-value enum represents a constant / literal if not 'required' in schema : schema [ 'required' ] = [] #add required property if missing schema [ 'required' ] . extend ([ 'osl_template' , 'osl_footer' ]) pprint ( schema ) page . set_content ( json . dumps ( schema , indent = 4 ) . replace ( \"dollarref\" , \"$ref\" )) page . edit ( \"Create / update schema from pydantic BaseModel\" ) for base in schema_registration . schema_bases : page = self . site . get_WtPage ( \"JsonSchema:\" + base ) schema = json . loads ( page . get_content ()) refs = schema [ 'properties' ][ 'extensions' ][ 'items' ][ 'oneOf' ] #pprint(refs) schema_url = '/wiki/JsonSchema:' + schema_registration . schema_name + '?action=raw' missing = True for ref in refs : if ref [ '$ref' ] == schema_url : missing = False print ( missing ) if missing : refs . append ({ '$ref' : schema_url }) #pprint(schema) page . set_content ( json . dumps ( schema , indent = 4 )) page . edit ( \"add extension schema \" + schema_registration . schema_name ) Bases: BaseModel the model class Source code in src/osl.py 64 65 66 67 68 69 70 71 72 73 74 @model . _basemodel_decorator class SchemaRegistration ( BaseModel ): \"\"\" the model class \"\"\" model_cls : ModelMetaclass \"\"\" the name of the schema \"\"\" schema_name : str schema_bases : List [ str ] = [ \"KB/Entity\" ]","title":"register_schema()"},{"location":"osl/#osl.OSL.SchemaRegistration.model_cls","text":"the name of the schema","title":"model_cls"},{"location":"tools/","text":"Collection of helper functions copy_list_of_wiki_pages ( title_list , site0 , site1 , overwrite , callback = None ) Parameters: Name Type Description Default title_list list required site0 mwclient . client . Site Source site object from mwclient lib required site1 mwclient . client . Site Target site object from mwclient lib required overwrite bool Whether to overwrite existing pages at target site required callback NoneType or function Function passed over, to perform operation on the titles of the source pages and to be passed as title of the target pages. See examples below. Example functions: capitalize = lambda x: x.capitalize() def change_namespace(title, namespace): if \":\" in namespace: namespace = namespace.split(\":\")[0] if \":\" in title: splits = title.split(\":\") old_name = splits[1].capitalize() new_title = namespace + \":\" + old_name else: new_title = namespace + \":\" + title.capitalize() return new_title Examples of passing a function as parameter: callback = capitalize callback = lambda x: x.lower() None Returns: Name Type Description results_dict dict Dictionary, containing the results of the copying operations Source code in src/wiki_tools.py 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 def copy_list_of_wiki_pages ( title_list , site0 , site1 , overwrite , callback = None ): \"\"\" Parameters ---------- title_list : list site0 : mwclient.client.Site Source site object from mwclient lib site1 : mwclient.client.Site Target site object from mwclient lib overwrite : bool Whether to overwrite existing pages at target site callback : NoneType or function Function passed over, to perform operation on the titles of the source pages and to be passed as title of the target pages. See examples below. Example functions: capitalize = lambda x: x.capitalize() def change_namespace(title, namespace): if \":\" in namespace: namespace = namespace.split(\":\")[0] if \":\" in title: splits = title.split(\":\") old_name = splits[1].capitalize() new_title = namespace + \":\" + old_name else: new_title = namespace + \":\" + title.capitalize() return new_title Examples of passing a function as parameter: callback = capitalize callback = lambda x: x.lower() Returns ------- results_dict : dict Dictionary, containing the results of the copying operations \"\"\" success_list = list () fail_list = list () for title0 in title_list : if callback is None : title1 = title0 else : title1 = callback ( title0 ) success = copy_wiki_page ( title0 , title1 , site0 , site1 , overwrite ) if success : success_list . append ( title1 ) else : fail_list . append ( title1 ) results_dict = { \"Successfully copied pages\" : success_list , \"Pages failed to copy\" : fail_list } return results_dict copy_wiki_page ( title0 , title1 , site0 , site1 , overwrite = True ) Parameters: Name Type Description Default title0 str Title of the source page required title1 str Title of the target page required site0 mwclient . client . Site Source site object from mwclient lib required site1 mwclient . client . Site Target site object from mwclient lib required overwrite bool Whether to overwrite existing pages at target site True Returns: Name Type Description success bool Source code in src/wiki_tools.py 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 def copy_wiki_page ( title0 , title1 , site0 , site1 , overwrite = True ): \"\"\" Parameters ---------- title0 : str Title of the source page title1 : str Title of the target page site0 : mwclient.client.Site Source site object from mwclient lib site1 : mwclient.client.Site Target site object from mwclient lib overwrite : bool Whether to overwrite existing pages at target site Returns ------- success: bool \"\"\" if title0 . lower () == title1 . lower () and site0 == site1 : # copy on it self = no action necessary success = True else : page0 = site0 . pages [ title0 ] content = page0 . text () if overwrite : success = create_or_overwrite_wiki_page ( title1 , content , site1 ) else : search_result = search_wiki_page ( title1 , site1 ) if search_result [ \"Result\" ] and search_result [ \"Exact match\" ]: # page already exists success = False else : # search_result[\"Result\"] == True/False, search_result[\"Exact match\"] == False success = create_or_overwrite_wiki_page ( title1 , content , site1 ) return success create_flat_content_structure_from_wikitext ( text , array_mode = 'force' ) Create a flat python dict (aka 'flat_content_structure' = 'wikiJson') representing the content of the page Parameters: Name Type Description Default text str the wiki source text required array_mode str defines how to parse template params array_mode / param value value; value;value comment 'force': array array array always create an array 'only_multiple': literal literal array create only when more than one value is given 'delimiter_present': literal array array create array if at least one separator char is present 'force' Returns: Name Type Description res dict (aka 'flat_content_structure' = 'wikiJson') Source code in src/wiki_tools.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 def create_flat_content_structure_from_wikitext ( text : str , array_mode : str = 'force' ): \"\"\"Create a flat python dict (aka 'flat_content_structure' = 'wikiJson') representing the content of the page Parameters ---------- text : str the wiki source text array_mode : str defines how to parse template params array_mode / param value value; value;value comment 'force': array array array always create an array 'only_multiple': literal literal array create only when more than one value is given 'delimiter_present': literal array array create array if at least one separator char is present Returns ------- res : dict (aka 'flat_content_structure' = 'wikiJson') \"\"\" res = [] text = text . strip () existing_code = mwparserfromhell . parse ( text ) t_count = 0 for i in range ( 0 , len ( existing_code . nodes )): n = existing_code . nodes . pop ( 0 ) #returns first layer of nodes. filter() returns also template args if ( type ( n ) is mwparserfromhell . nodes . template . Template ): t_count += 1 wt = {} #print(f\"Template: {t.name} = {t}\") wt [ str ( n . name ) . strip ()] = {} for p in n . params : #print(f\" Param: {p.name} = {p.value} ({type(p.value)})\") wt [ str ( n . name ) . strip ()][ str ( p . name )] = create_flat_content_structure_from_wikitext ( str ( p . value ), array_mode ) res . append ( wt ) else : if len ( res ) == 0 or type ( res [ - 1 ]) is dict : res . append ( \"\" ) res [ - 1 ] = res [ - 1 ] + str ( n ) #append to previos string if exists #for i, x in enumerate(res): # if type(x) is str: res[i] = x.strip() #remove whitespace res = [ x for x in res if x and not ( type ( x ) is str and x . isspace ())] if t_count == 0 : res = text values = str ( text ) . strip () . split ( ';' ) if array_mode == 'force' : res = values elif array_mode == 'only_multiple' and len ( values ) > 1 : res = values elif array_mode == 'separator_present' and ';' in text : res = values return res create_or_overwrite_wiki_page ( title , content , site ) Creates a page with the passed title and content. If the page already exists, the prior content is replaced with the passed content. Parameters: Name Type Description Default title str Title of the wiki page, e. g. User:Someone1234 required content str required site mwclient . client . Site Site object from mwclient lib required Returns: Name Type Description success bool Source code in src/wiki_tools.py 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 def create_or_overwrite_wiki_page ( title , content , site ): \"\"\"Creates a page with the passed title and content. If the page already exists, the prior content is replaced with the passed content. Parameters ---------- title : str Title of the wiki page, e. g. User:Someone1234 content : str site : mwclient.client.Site Site object from mwclient lib Returns ------- success : bool \"\"\" target_page = site . pages [ title ] target_page . edit ( content , '[bot] create page' ) success = True return success create_or_update_wiki_page_with_template ( title , content , site , overwrite_with_empty = False ) Creates a wiki page with a template included in the content. If the page does already exist, the parameters within the template are update Parameters: Name Type Description Default title str Title of the wiki page, e. g. User:Someone1234 required content str required site mwclient . client . Site Site object from mwclient lib required overwrite_with_empty bool Decided whether a template parameter's value in an preexisting page is overwritten with an empty value False Returns: Name Type Description success bool Source code in src/wiki_tools.py 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 def create_or_update_wiki_page_with_template ( title , content , site , overwrite_with_empty = False ): \"\"\"Creates a wiki page with a template included in the content. If the page does already exist, the parameters within the template are update Parameters ---------- title : str Title of the wiki page, e. g. User:Someone1234 content : str site : mwclient.client.Site Site object from mwclient lib overwrite_with_empty : bool Decided whether a template parameter's value in an preexisting page is overwritten with an empty value Returns ------- success : bool \"\"\" search_result = search_wiki_page ( title , site ) if search_result [ \"Result\" ]: existing_page = site . pages [ title ] existing_text = existing_page . text () # update the page's content (template only) updated_content = update_template_within_wikitext ( text = existing_text , template_text = content , overwrite_with_empty = overwrite_with_empty ) success = create_or_overwrite_wiki_page ( title , updated_content , site ) else : # just create the page success = create_or_overwrite_wiki_page ( title , content , site ) return success create_site_object ( domain , password_file = '' ) Parameters ---------- domain : str password_file : str (path to file with <username> ) Returns ------- site : mwclient.client.Site Site object from mwclient lib Source code in src/wiki_tools.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def create_site_object ( domain , password_file = \"\" ): \"\"\" Parameters ---------- domain : str password_file : str (path to file with <username>\\n<password>) Returns ------- site : mwclient.client.Site Site object from mwclient lib \"\"\" domain_dict = { \"wiki-dev\" : { \"Address\" : \"wiki-dev.open-semantic-lab.org\" } } if domain in domain_dict . keys (): domain = domain_dict [ domain ][ \"Address\" ] site = mwclient . Site ( domain , path = '/w/' ) if ( password_file != \"\" ): f = open ( password_file , \"r\" ) lines = f . readlines () user = lines [ 0 ] . strip () password = lines [ 1 ] . strip () f . close () else : user = input ( \"Enter bot username (username@botname)\" ) password = getpass . getpass ( \"Enter bot password\" ) site . login ( user , password ) del user del password return site delete_wiki_page ( title , site , reason ) Deletes the wiki page with the passed title, if it was found (exact match!), otherwise returns False Parameters: Name Type Description Default title str Title of the wiki page, e. g. User:Someone1234 required site mwclient . client . Site Site object from mwclient lib required reason str required Returns: Name Type Description success bool Source code in src/wiki_tools.py 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 def delete_wiki_page ( title , site , reason ): \"\"\"Deletes the wiki page with the passed title, if it was found (exact match!), otherwise returns False Parameters ---------- title : str Title of the wiki page, e. g. User:Someone1234 site : mwclient.client.Site Site object from mwclient lib reason : str Returns ------- success : bool \"\"\" try : page = site . pages [ title ] page . delete ( reason = reason , watch = False , unwatch = True , oldimage = False ) success = True except mwclient . errors . APIError : success = False return success edit_wiki_page_with_content_merge ( title , new_content , site , template_name ) Edits an existing wiki page, while merging the passed new content with the content of the existing page Parameters: Name Type Description Default title str Title of the wiki page, e. g. User:Someone1234 required new_content str required site mwclient . client . Site Site object from mwclient lib required template_name str required Returns: Name Type Description success bool Source code in src/wiki_tools.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 def edit_wiki_page_with_content_merge ( title , new_content , site , template_name ): \"\"\"Edits an existing wiki page, while merging the passed new content with the content of the existing page Parameters ---------- title : str Title of the wiki page, e. g. User:Someone1234 new_content : str site : mwclient.client.Site Site object from mwclient lib template_name : str Returns ------- success : bool \"\"\" search_result = search_wiki_page ( title , site ) if search_result [ \"Result\" ]: source_page = site . pages [ title ] source_page_content = source_page . text () # todo: test function new_content = merge_wiki_page_text ( new_content , source_page_content , template_name = template_name ) target_page = site . pages [ title ] target_page . edit ( new_content , '[bot] update of page content' ) success = True else : success = False return success extend_page_list_with_recursive_dependencies ( page_list , site ) Finds all included templates, properties and categories for a list of wiki pages and appends them to the list Parameters: Name Type Description Default page_list list or iterable List of pages required site mwclient . client . Site Site object from mwclient lib required Returns: Name Type Description page_list list Source code in src/wiki_tools.py 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 def extend_page_list_with_recursive_dependencies ( page_list , site ): \"\"\"Finds all included templates, properties and categories for a list of wiki pages and appends them to the list Parameters ---------- page_list : list or iterable List of pages site : mwclient.client.Site Site object from mwclient lib Returns ------- page_list : list \"\"\" page_list_iter = copy . deepcopy ( page_list ) for page in page_list_iter : # we provide the updates page list to prevent a revisit of the pages dependencies = find_dependencies_recursively ( page , site , dependencies = page_list , debug = False ) page_list . extend ( dependencies ) page_list = np . unique ( page_list ) return page_list find_dependencies ( wikitext , debug = False ) Finds templates, properties and categories within wikitext Parameters: Name Type Description Default wikitext str required debug bool Whether to print debugging messages False Returns: Name Type Description filtered_dependencies list Source code in src/wiki_tools.py 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 def find_dependencies ( wikitext , debug = False ): \"\"\"Finds templates, properties and categories within wikitext Parameters ---------- wikitext : str debug : bool Whether to print debugging messages Returns ------- filtered_dependencies : list \"\"\" dependencies = [] code = mwparserfromhell . parse ( wikitext ) for template in code . filter_templates ( recursive = True ): if template . name . split ( ':' )[ 0 ] . isupper (): if debug : print ( \"MagicWord: {} \" . format ( template . name )) elif template . name [ 0 ] == \"#\" : if debug : print ( \"ParserFunction: {} \" . format ( template . name )) if \"#set:\" in template . name or \"#declare:\" in template . name : if '=' in template . name . split ( ':' )[ 1 ]: # in case of '{{#set:HasIdPostfix={{{id_postfix}}} }}' property_ = \"Property:\" + template . name . split ( ':' )[ 1 ] . split ( '=' )[ 0 ] dependencies . append ( property_ ) if debug : print ( \"=> {} \" . format ( property_ )) for param in template . params : property_ = \"Property:\" + param . split ( '=' )[ 0 ] dependencies . append ( property_ ) if debug : print ( \"=> {} \" . format ( property_ )) else : if debug : print ( \"Template: {} \" . format ( template . name )) template_name = str ( template . name ) if ':' not in template . name : template_name = \"Template:\" + template_name dependencies . append ( template_name ) if debug : print ( \"=> {} \" . format ( template_name )) # for tag in code.filter_tags(recursive=True): # if (debug): print(\"Tag: {}\".format(tag)) for link in code . filter_wikilinks ( recursive = True ): if '::' in link : if debug : print ( \"Annotation: {} \" . format ( link )) property_ = \"Property:\" + link . split ( '::' )[ 0 ] . split ( '[[' )[ - 1 ] dependencies . append ( property_ ) if debug : print ( \"=> {} \" . format ( property_ )) if 'Category:' in link : if debug : print ( \"Category: {} \" . format ( link )) category = link . replace ( '[[' , '' ) . replace ( ']]' , '' ) dependencies . append ( str ( category )) if debug : print ( \"=> {} \" . format ( category )) else : if debug : print ( \"Link: {} \" . format ( link )) dependencies = np . unique ( dependencies ) . tolist () # remove duplicates filtered_dependencies = [] # do not manipulate the iterated object for dependency in dependencies : # ensure no leading or trailing white spaces dependency = dependency . strip () # very frew page titles listed here contain invalid characters \"\\n\" dependency = dependency . replace ( ' \\n ' , '' ) # see https://www.semantic-mediawiki.org/wiki/Help:Special_properties if 'Property:' in dependency and ( ' ' in dependency or '_' in dependency ): if debug : print ( \"Info: Remove presumptive built-in property {} \" . format ( dependency )) else : filtered_dependencies . append ( dependency ) return filtered_dependencies find_dependencies_recursively ( title , site , dependencies = [], debug = False ) Finds all included templates, properties and categories within a wiki page Parameters: Name Type Description Default title str Title of the wiki page, e. g. User:Someone1234 required site mwclient . client . Site Site object from mwclient lib required dependencies List of already found dependent titles [] debug bool Whether to print debugging messages False Returns: Name Type Description dependencies list Source code in src/wiki_tools.py 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 def find_dependencies_recursively ( title , site , dependencies = [], debug = False ): \"\"\"Finds all included templates, properties and categories within a wiki page Parameters ---------- title : str Title of the wiki page, e. g. User:Someone1234 site : mwclient.client.Site Site object from mwclient lib dependencies List of already found dependent titles debug : bool Whether to print debugging messages Returns ------- dependencies : list \"\"\" title = title . replace ( \"{\" , \"\" ) . replace ( \"}\" , \"\" ) page = site . pages [ title ] content = page . text () new_dependencies = find_dependencies ( content , debug ) for dependency in new_dependencies : if dependency not in dependencies : # for circular dependencies dependencies . append ( dependency ) if debug : print ( \"Scan nested {} \" . format ( dependency )) find_dependencies_recursively ( dependency , site , dependencies = dependencies , debug = debug ) return dependencies get_wikitext_from_flat_content_dict ( d ) Create wiki source text from a flat python dict representing a wiki template Parameters: Name Type Description Default d dict flat python dict e.g.: {\"HeaderTemplate\": {\"param\": \"value\"}} required Returns: Name Type Description wt str wiki text Source code in src/wiki_tools.py 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 def get_wikitext_from_flat_content_dict ( d : dict ): \"\"\"Create wiki source text from a flat python dict representing a wiki template Parameters ---------- d : dict flat python dict e.g.: {\"HeaderTemplate\": {\"param\": \"value\"}} Returns ------- wt : str wiki text \"\"\" wt = \"\" for key , value in d . items (): #print(\"key: {}, valuetype: {}, value: {}\".format(key, type(value), \"\")) if isinstance ( value , dict ): #print(\"dict\") wt += \"{{\" + key wt += get_wikitext_from_flat_content_dict ( value ) wt += \" \\n }}\" elif isinstance ( value , list ): #print(\"list\") wt += \" \\n | {} =\" . format ( key ) string_index = 0 for index , element in enumerate ( value ): if isinstance ( element , dict ): wt += get_wikitext_from_flat_content_dict ( element ) #wt += \"\\n{{\" + element #wt += get_wikitext_from_dict(element) #wt += \"\\n}}\" else : if ( string_index != index ): print ( f \"Warning: template param ' { key } ' has mixed template/string values: { value } \" ) if string_index > 0 and element and not element . strip () . isspace (): wt += \";\" wt += element string_index += 1 else : #print(\"literal\") wt += \" \\n | {} = {} \" . format ( key , value ) return wt get_wikitext_from_flat_content_structure ( content ) Create wiki source text from the content list (aka 'flat_content_structure' = 'wikiJson') of the page Parameters: Name Type Description Default content list content list, mixed objects (templates) and free text (aka 'flat_content_structure' = 'wikiJson') e.g.: [{\"HeaderTemplate\": {\"param\": \"value\"}}, \"freetext\", {\"FooterTemplate\": {\"param2\": \"value\"}}] required Returns: Name Type Description wt wiki text Source code in src/wiki_tools.py 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 def get_wikitext_from_flat_content_structure ( content ): \"\"\"Create wiki source text from the content list (aka 'flat_content_structure' = 'wikiJson') of the page Parameters ---------- content : list content list, mixed objects (templates) and free text (aka 'flat_content_structure' = 'wikiJson') e.g.: [{\"HeaderTemplate\": {\"param\": \"value\"}}, \"freetext\", {\"FooterTemplate\": {\"param2\": \"value\"}}] Returns ------- wt : wiki text \"\"\" wt = \"\" for content_element in content : if isinstance ( content_element , dict ): wt += get_wikitext_from_flat_content_dict ( content_element ) elif isinstance ( content_element , str ): wt += content_element #\"\\n\" + content_element else : print ( \"Error: content element is not dict or string: {} \" . format ( content_element )) return wt merge_wiki_page_text ( text1 , text2 , template_name , subtemplate_param = '' , subtemplate_name = '' ) Not fully tested function! Parameters: Name Type Description Default text1 required text2 required template_name required subtemplate_param '' subtemplate_name '' Returns: Name Type Description non_empty_lines str Source code in src/wiki_tools.py 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 def merge_wiki_page_text ( text1 , text2 , template_name , subtemplate_param = \"\" , subtemplate_name = \"\" ): \"\"\"Not fully tested function! Parameters ---------- text1 text2 template_name subtemplate_param subtemplate_name Returns ------- non_empty_lines : str \"\"\" if text1 == text2 : return text1 if text1 == \"\" : return text2 if text2 == \"\" : return text1 code1 = mwparserfromhell . parse ( text1 ) code2 = mwparserfromhell . parse ( text2 ) r1 = [] r2 = [] for template in code1 . filter_templates ( recursive = True ): if template . name . matches ( template_name ): t1 = template if template . name . matches ( subtemplate_name ): r1 . append ( template ) for template in code2 . filter_templates ( recursive = True ): if template . name . matches ( template_name ): t2 = template if template . name . matches ( subtemplate_name ): r2 . append ( template ) # print(\"T1: \" + str(t1)) # print(\"T2: \" + str(t2)) for p in t2 . params : if not t1 . has ( p . name ): t1 . add ( p . name , p . value ) if subtemplate_param != \"\" : t1 . remove ( subtemplate_param ) for rel2 in r2 : exists = False for rel1 in r1 : all_params_equal = True for p in rel2 . params : if rel1 . has ( p . name ): if not rel1 . get ( p . name ) . value . matches ( rel2 . get ( p . name ) . value ): all_params_equal = False # print(\"Compare {}:{} with :{} -> res={}\".format(p.name, rel1.get(p.name).value,rel2.get(p.name).value, # rel1.get(p.name).value.matches(rel2.get(p.name).value))) else : all_params_equal = False if all_params_equal : exists = True if not exists : r1 . append ( rel2 ) r1string = \"\" for rel1 in r1 : r1string += \" \\r\\n \" + str ( rel1 ) t1 . add ( subtemplate_param , r1string ) # print(\"Tmerged: \" + str(t1)) non_empty_lines = \" \\n \" . join ([ ll . rstrip () for ll in str ( t1 ) . splitlines () if ll . strip ()]) return non_empty_lines prefix_search ( site , text ) Parameters: Name Type Description Default site mwclient . client . Site Site object from mwclient lib required text str required Returns: Name Type Description page_list list Source code in src/wiki_tools.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def prefix_search ( site , text ): \"\"\" Parameters ---------- site : mwclient.client.Site Site object from mwclient lib text : str Returns ------- page_list : list \"\"\" page_list = [] result = site . api ( 'query' , list = \"prefixsearch\" , pssearch = text , pslimit = 1000 , format = 'json' ) if len ( result [ 'query' ][ 'prefixsearch' ]) == 0 : print ( 'No results' ) else : for page in result [ 'query' ][ 'prefixsearch' ]: title = page [ 'title' ] print ( title ) page_list . append ( title ) return page_list schemaJson2WikiJson ( schemaJson , isRoot = True ) Create content representation of a page (aka 'flat_content_structure' = 'wikiJson') from the osl schema-compatible json Parameters: Name Type Description Default schemaJson dict schema-compatible json e.g.: {osl_template: \"HeaderTemplate\", \"param\": \"value\", \"osl_wikitext\": \"freetext\", \"osl_footer\": {\"osl_template\": \"FooterTemplate\", \"param2\": \"value2\"}} required isRoot: boolean indicates first call in recursion Returns: Name Type Description wikiJson list content list, mixed objects (templates) and free text (aka 'flat_content_structure' = 'wikiJson') e.g.: [{\"HeaderTemplate\": {\"param\": \"value\"}}, \"freetext\", {\"FooterTemplate\": {\"param2\": \"value\"}}] Source code in src/wiki_tools.py 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 def schemaJson2WikiJson ( schemaJson , isRoot = True ): \"\"\"Create content representation of a page (aka 'flat_content_structure' = 'wikiJson') from the osl schema-compatible json Parameters ---------- schemaJson : dict schema-compatible json e.g.: {osl_template: \"HeaderTemplate\", \"param\": \"value\", \"osl_wikitext\": \"freetext\", \"osl_footer\": {\"osl_template\": \"FooterTemplate\", \"param2\": \"value2\"}} isRoot: boolean indicates first call in recursion Returns ------- wikiJson : list content list, mixed objects (templates) and free text (aka 'flat_content_structure' = 'wikiJson') e.g.: [{\"HeaderTemplate\": {\"param\": \"value\"}}, \"freetext\", {\"FooterTemplate\": {\"param2\": \"value\"}}] \"\"\" wikiJson = [{}, \"\" , {}]; #header, freetext, footer template = \"\" footer_template = \"\" if 'osl_template' in schemaJson : template = schemaJson [ 'osl_template' ] wikiJson [ 0 ][ template ] = {} else : print ( \"Error: Mandatory property 'osl_template' not found in schemaJson\" , schemaJson ) return if 'osl_wikitext' in schemaJson : wikiJson [ 1 ] = schemaJson [ 'osl_wikitext' ] if 'osl_footer' in schemaJson : wikiJson [ 2 ] = schemaJson2WikiJson ( schemaJson [ 'osl_footer' ], False )[ 0 ] footer_template = schemaJson [ 'osl_footer' ][ 'osl_template' ] wikiJson [ 2 ][ footer_template ][ 'extensions' ] = [] for key in schemaJson : if key . startswith ( '_' ) or key . startswith ( 'osl_template' ) or key . startswith ( 'osl_wikitext' ) or key . startswith ( 'osl_footer' ): continue #exclude private and reserved keywords if schemaJson [ key ] == None : continue if isinstance ( schemaJson [ key ], list ): wikiJson [ 0 ][ template ][ key ] = [] for subSchemaJson in schemaJson [ key ]: subWikiJson = schemaJson2WikiJson ( subSchemaJson , False ) wikiJson [ 0 ][ template ][ key ] . append ( subWikiJson [ 0 ]) if ( key == \"extensions\" ): wikiJson [ 2 ][ footer_template ][ 'extensions' ] . append ( subWikiJson [ 2 ]) elif isinstance ( schemaJson [ key ], dict ): subWikiJson = schemaJson2WikiJson ( subSchemaJson , False ) wikiJson [ 0 ][ template ][ key ] = subWikiJson [ 0 ] else : wikiJson [ 0 ][ template ][ key ] = schemaJson [ key ] return wikiJson search_redirection_sources ( site , target_title , debug = False ) Returns a list of pages redirecting to the page with target_title per #REDIRECT [[target]] syntax Parameters: Name Type Description Default site mwclient . client . Site Site object from mwclient lib required target_title str Title of the target wiki page required Returns: Name Type Description page_list list of pages redirecting to the page with target_title Source code in src/wiki_tools.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def search_redirection_sources ( site , target_title , debug = False ): \"\"\"Returns a list of pages redirecting to the page with target_title per #REDIRECT [[target]] syntax Parameters ---------- site : mwclient.client.Site Site object from mwclient lib target_title : str Title of the target wiki page Returns ------- page_list : list of pages redirecting to the page with target_title \"\"\" page_list = [] result = site . api ( 'query' , titles = target_title , prop = 'redirects' , format = 'json' ) if len ( result [ 'query' ][ 'pages' ]) == 0 : if ( debug ): print ( 'No results' ) else : for page in result [ 'query' ][ 'pages' ]: if not 'redirects' in result [ 'query' ][ 'pages' ][ page ]: if ( debug ): print ( 'No results' ) else : for redirecting_source in result [ 'query' ][ 'pages' ][ page ][ 'redirects' ]: title = redirecting_source [ 'title' ] page_list . append ( title ) return page_list search_wiki_page ( title , site ) Adds exact match functionality with ignore-case on top of the prefix_search()'s functionality Parameters: Name Type Description Default title str Title of the wiki page, e. g. User:Someone1234 required site mwclient . client . Site Site object from mwclient lib required Returns: Name Type Description result_dict dict Source code in src/wiki_tools.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def search_wiki_page ( title , site ): \"\"\"Adds exact match functionality with ignore-case on top of the prefix_search()'s functionality Parameters ---------- title : str Title of the wiki page, e. g. User:Someone1234 site : mwclient.client.Site Site object from mwclient lib Returns ------- result_dict : dict \"\"\" result = site . api ( 'query' , list = \"prefixsearch\" , pssearch = title , pslimit = 1000 , format = 'json' ) if len ( result [ 'query' ][ 'prefixsearch' ]) == 0 : return { \"Result\" : False , \"List\" : list ()} else : exact_match = False page_title_list = list () for page in result [ 'query' ][ 'prefixsearch' ]: page_title = page [ 'title' ] page_title_list . append ( page_title ) if page_title . lower () == title . lower (): exact_match = True result_dict = { \"Result\" : True , \"List\" : page_title_list , \"Exact match\" : exact_match } return result_dict semantic_search ( site , query ) Parameters: Name Type Description Default site mwclient . client . Site Site object from mwclient lib required query required Returns: Name Type Description page_list list Source code in src/wiki_tools.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 def semantic_search ( site , query ): \"\"\" Parameters ---------- site : mwclient.client.Site Site object from mwclient lib query Returns ------- page_list : list \"\"\" page_list = [] query += \"|limit=1000\" result = site . api ( 'ask' , query = query , format = 'json' ) if len ( result [ 'query' ][ 'results' ]) == 0 : print ( \"Query ' {} ' returned no results\" . format ( query )) else : print ( \"Query ' {} ' returned {} results\" . format ( query , len ( result [ 'query' ][ 'results' ]))) for page in result [ 'query' ][ 'results' ] . values (): # why do we do the following? if 'printouts' in page : title = page [ 'fulltext' ] if '#' not in title : print ( title ) # original position of \"page_list.append(title)\" line page_list . append ( title ) return page_list update_template_within_wikitext ( text , template_text , delete = False , remove_empty_lines = False , overwrite_with_empty = False ) Updates the template parameters in an existing wiki with a provided new Parameters: Name Type Description Default text str The existing text required template_text str The template text with new data required delete bool If true, params not defined in get removed from False remove_empty_lines bool If true, function will cleanup empty lines within the template code created by the underlying mwparserfromhell lib (wanted), but also within the wiki text around it (unwanted) False overwrite_with_empty bool If true, parameters in the existing tempalte will be overwritten even if the parameter value in the template_text is empty False Returns: Name Type Description new_text str Source code in src/wiki_tools.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 def update_template_within_wikitext ( text , template_text , delete = False , remove_empty_lines = False , overwrite_with_empty = False ): \"\"\"Updates the template parameters in an existing wiki <text> with a provided new <template_text> Parameters ---------- text : str The existing text template_text : str The template text with new data delete : bool If true, params not defined in <template_text> get removed from <text> remove_empty_lines : bool If true, function will cleanup empty lines within the template code created by the underlying mwparserfromhell lib (wanted), but also within the wiki text around it (unwanted) overwrite_with_empty : bool If true, parameters in the existing tempalte will be overwritten even if the parameter value in the template_text is empty Returns ------- new_text : str \"\"\" if template_text == text : return template_text if template_text == \"\" : return text if text == \"\" : return template_text new_code = mwparserfromhell . parse ( template_text ) new_template = new_code . filter_templates ()[ 0 ] existing_code = mwparserfromhell . parse ( text ) template_names_matched = False for template in existing_code . filter_templates ( recursive = True ): if template . name . matches ( new_template . name ): existing_template = template template_names_matched = True break if template_names_matched : for p in new_template . params : if existing_template . has ( p . name ): if p . value != \"\" or overwrite_with_empty : existing_template . get ( p . name ) . value = p . value else : existing_template . add ( p . name , p . value ) if delete : for p in existing_template . params : if not new_template . has ( p . name ): existing_template . remove ( p ) else : # the original text did not contain a matching template # options: 1) include the new template # 2) replace the existing template - but what if multiple tempaltes exist on that page? pass # print(\"Tmerged: \\n\" + str(existing_template)) # print(\"Text merged: \" + str(existing_code)) new_text = str ( existing_code ) # this will cleanup empty lines within the template code (wanted), but also within the wiki text around it (unwanted) if remove_empty_lines : new_text = \" \\n \" . join ([ ll . rstrip () for ll in str ( new_text ) . splitlines () if ll . strip ()]) return new_text wikiJson2SchemaJson ( schema , wikiJson ) Create osl schema-compatible json from the content representation of a page (aka 'flat_content_structure' = 'wikiJson') Parameters: Name Type Description Default wikiJson list content list, mixed objects (templates) and free text (aka 'flat_content_structure' = 'wikiJson') e.g.: [{\"HeaderTemplate\": {\"param\": \"value\"}}, \"freetext\", {\"FooterTemplate\": {\"param2\": \"value\"}}] required Returns: Name Type Description schemaJson dict schema-compatible json e.g.: {osl_template: \"HeaderTemplate\", \"param\": \"value\", \"osl_wikitext\": \"freetext\", \"osl_footer\": {\"osl_template\": \"FooterTemplate\", \"param2\": \"value2\"}} Source code in src/wiki_tools.py 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 def wikiJson2SchemaJson ( schema , wikiJson ): \"\"\"Create osl schema-compatible json from the content representation of a page (aka 'flat_content_structure' = 'wikiJson') Parameters ---------- wikiJson : list content list, mixed objects (templates) and free text (aka 'flat_content_structure' = 'wikiJson') e.g.: [{\"HeaderTemplate\": {\"param\": \"value\"}}, \"freetext\", {\"FooterTemplate\": {\"param2\": \"value\"}}] Returns ------- schemaJson : dict schema-compatible json e.g.: {osl_template: \"HeaderTemplate\", \"param\": \"value\", \"osl_wikitext\": \"freetext\", \"osl_footer\": {\"osl_template\": \"FooterTemplate\", \"param2\": \"value2\"}} \"\"\" schemaJson = {} if not isinstance ( wikiJson [ 0 ], dict ) or not isinstance ( wikiJson [ 1 ], str ) or not isinstance ( wikiJson [ 2 ], dict ): print ( \"Error: Invalid wikiJson:\" , wikiJson ) return schemaJson schemaJson = wikiJson2SchemaJsonRecursion ( schema , wikiJson [ 0 ], wikiJson [ 2 ]) schemaJson [ \"osl_wikitext\" ] = wikiJson [ 1 ] return schemaJson wikiJson2SchemaJsonRecursion ( schema , wikiJson , footerWikiJson = None ) internal recursion function of wikiJson2SchemaJson() Parameters: Name Type Description Default wikiJson list wiki template representation e.g.: {\"HeaderTemplate\": {\"param\": \"value\"}} required footerWikiJson : list wiki footer template representation e.g.: {\"FooterTemplate\": {\"param2\": \"value2\"}} Returns: Name Type Description schemaJson dict schema-compatible json e.g.: {osl_template: \"HeaderTemplate\", \"param\": \"value\", \"osl_footer\": {\"osl_template\": \"FooterTemplate\", \"param2\": \"value2\"}} Source code in src/wiki_tools.py 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 def wikiJson2SchemaJsonRecursion ( schema : dict , wikiJson : dict , footerWikiJson = None ): \"\"\"internal recursion function of wikiJson2SchemaJson() Parameters ---------- wikiJson : list wiki template representation e.g.: {\"HeaderTemplate\": {\"param\": \"value\"}} footerWikiJson : list wiki footer template representation e.g.: {\"FooterTemplate\": {\"param2\": \"value2\"}} Returns ------- schemaJson : dict schema-compatible json e.g.: {osl_template: \"HeaderTemplate\", \"param\": \"value\", \"osl_footer\": {\"osl_template\": \"FooterTemplate\", \"param2\": \"value2\"}} \"\"\" schemaJson = {} if footerWikiJson != None : schemaJson [ 'osl_footer' ] = wikiJson2SchemaJsonRecursion ( schema , footerWikiJson ) for key in wikiJson : value = wikiJson [ key ] if isinstance ( value , list ): schemaJson [ key ] = [] for index , element in enumerate ( value ): element = value [ index ] if isinstance ( element , dict ): if key == \"extensions\" : if footerWikiJson != None : #we asume that every extension provides also a footer template nextFooter = footerWikiJson [ schemaJson [ 'osl_footer' ][ 'osl_template' ]][ 'extensions' ][ index ] schemaJson [ key ] . append ( wikiJson2SchemaJsonRecursion ( schema , element , nextFooter )) else : schemaJson [ key ] . append ( wikiJson2SchemaJsonRecursion ( schema , element )) else : schemaJson [ key ] . append ( element ) elif isinstance ( value , dict ): schemaJson = wikiJson2SchemaJsonRecursion ( schema , value , footerWikiJson ) schemaJson [ 'osl_template' ] = key else : schemaJson [ key ] = value if 'osl_template' in schemaJson : jsonpath_expr = parse ( '$..properties' ) #[?osl_template.default = \"' + schemaJson['osl_template'] + '\"]') schema_def = {} #print(\"Search for \", schemaJson['osl_template']) for match in jsonpath_expr . find ( schema ): value = match . value if value [ 'osl_template' ][ 'default' ] == schemaJson [ 'osl_template' ]: schema_def = match . value #print(schema_def) for key in list ( schemaJson . keys ()): if key in schema_def and 'type' in schema_def [ key ]: #use schema to resolve types if schema_def [ key ][ 'type' ] == 'integer' : schemaJson [ key ] = int ( schemaJson [ key ]) elif schema_def [ key ][ 'type' ] == 'float' : schemaJson [ key ] = float ( schemaJson [ key ]) elif schema_def [ key ][ 'type' ] == 'number' : schemaJson [ key ] = float ( schemaJson [ key ]) elif schema_def [ key ][ 'type' ] == 'string' : schemaJson [ key ] = str ( schemaJson [ key ]) elif schema_def [ key ][ 'type' ] == 'array' : if not isinstance ( schemaJson [ key ], list ): del schemaJson [ key ] elif len ( schemaJson [ key ]) == 0 : del schemaJson [ key ] else : #fall back if schemaJson [ key ] == \"\" and key == 'extensions' : del schemaJson [ key ] elif isinstance ( schemaJson [ key ], list ): #wikiJson defaults are lists, even for single or empty values if len ( schemaJson [ key ]) == 0 : del schemaJson [ key ] #elif len(schemaJson[key]) == 1: schemaJson[key] = schemaJson[key][0] return schemaJson","title":"Tools"},{"location":"tools/#wiki_tools.copy_list_of_wiki_pages","text":"Parameters: Name Type Description Default title_list list required site0 mwclient . client . Site Source site object from mwclient lib required site1 mwclient . client . Site Target site object from mwclient lib required overwrite bool Whether to overwrite existing pages at target site required callback NoneType or function Function passed over, to perform operation on the titles of the source pages and to be passed as title of the target pages. See examples below. Example functions: capitalize = lambda x: x.capitalize() def change_namespace(title, namespace): if \":\" in namespace: namespace = namespace.split(\":\")[0] if \":\" in title: splits = title.split(\":\") old_name = splits[1].capitalize() new_title = namespace + \":\" + old_name else: new_title = namespace + \":\" + title.capitalize() return new_title Examples of passing a function as parameter: callback = capitalize callback = lambda x: x.lower() None Returns: Name Type Description results_dict dict Dictionary, containing the results of the copying operations Source code in src/wiki_tools.py 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 def copy_list_of_wiki_pages ( title_list , site0 , site1 , overwrite , callback = None ): \"\"\" Parameters ---------- title_list : list site0 : mwclient.client.Site Source site object from mwclient lib site1 : mwclient.client.Site Target site object from mwclient lib overwrite : bool Whether to overwrite existing pages at target site callback : NoneType or function Function passed over, to perform operation on the titles of the source pages and to be passed as title of the target pages. See examples below. Example functions: capitalize = lambda x: x.capitalize() def change_namespace(title, namespace): if \":\" in namespace: namespace = namespace.split(\":\")[0] if \":\" in title: splits = title.split(\":\") old_name = splits[1].capitalize() new_title = namespace + \":\" + old_name else: new_title = namespace + \":\" + title.capitalize() return new_title Examples of passing a function as parameter: callback = capitalize callback = lambda x: x.lower() Returns ------- results_dict : dict Dictionary, containing the results of the copying operations \"\"\" success_list = list () fail_list = list () for title0 in title_list : if callback is None : title1 = title0 else : title1 = callback ( title0 ) success = copy_wiki_page ( title0 , title1 , site0 , site1 , overwrite ) if success : success_list . append ( title1 ) else : fail_list . append ( title1 ) results_dict = { \"Successfully copied pages\" : success_list , \"Pages failed to copy\" : fail_list } return results_dict","title":"copy_list_of_wiki_pages()"},{"location":"tools/#wiki_tools.copy_wiki_page","text":"Parameters: Name Type Description Default title0 str Title of the source page required title1 str Title of the target page required site0 mwclient . client . Site Source site object from mwclient lib required site1 mwclient . client . Site Target site object from mwclient lib required overwrite bool Whether to overwrite existing pages at target site True Returns: Name Type Description success bool Source code in src/wiki_tools.py 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 def copy_wiki_page ( title0 , title1 , site0 , site1 , overwrite = True ): \"\"\" Parameters ---------- title0 : str Title of the source page title1 : str Title of the target page site0 : mwclient.client.Site Source site object from mwclient lib site1 : mwclient.client.Site Target site object from mwclient lib overwrite : bool Whether to overwrite existing pages at target site Returns ------- success: bool \"\"\" if title0 . lower () == title1 . lower () and site0 == site1 : # copy on it self = no action necessary success = True else : page0 = site0 . pages [ title0 ] content = page0 . text () if overwrite : success = create_or_overwrite_wiki_page ( title1 , content , site1 ) else : search_result = search_wiki_page ( title1 , site1 ) if search_result [ \"Result\" ] and search_result [ \"Exact match\" ]: # page already exists success = False else : # search_result[\"Result\"] == True/False, search_result[\"Exact match\"] == False success = create_or_overwrite_wiki_page ( title1 , content , site1 ) return success","title":"copy_wiki_page()"},{"location":"tools/#wiki_tools.create_flat_content_structure_from_wikitext","text":"Create a flat python dict (aka 'flat_content_structure' = 'wikiJson') representing the content of the page Parameters: Name Type Description Default text str the wiki source text required array_mode str defines how to parse template params array_mode / param value value; value;value comment 'force': array array array always create an array 'only_multiple': literal literal array create only when more than one value is given 'delimiter_present': literal array array create array if at least one separator char is present 'force' Returns: Name Type Description res dict (aka 'flat_content_structure' = 'wikiJson') Source code in src/wiki_tools.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 def create_flat_content_structure_from_wikitext ( text : str , array_mode : str = 'force' ): \"\"\"Create a flat python dict (aka 'flat_content_structure' = 'wikiJson') representing the content of the page Parameters ---------- text : str the wiki source text array_mode : str defines how to parse template params array_mode / param value value; value;value comment 'force': array array array always create an array 'only_multiple': literal literal array create only when more than one value is given 'delimiter_present': literal array array create array if at least one separator char is present Returns ------- res : dict (aka 'flat_content_structure' = 'wikiJson') \"\"\" res = [] text = text . strip () existing_code = mwparserfromhell . parse ( text ) t_count = 0 for i in range ( 0 , len ( existing_code . nodes )): n = existing_code . nodes . pop ( 0 ) #returns first layer of nodes. filter() returns also template args if ( type ( n ) is mwparserfromhell . nodes . template . Template ): t_count += 1 wt = {} #print(f\"Template: {t.name} = {t}\") wt [ str ( n . name ) . strip ()] = {} for p in n . params : #print(f\" Param: {p.name} = {p.value} ({type(p.value)})\") wt [ str ( n . name ) . strip ()][ str ( p . name )] = create_flat_content_structure_from_wikitext ( str ( p . value ), array_mode ) res . append ( wt ) else : if len ( res ) == 0 or type ( res [ - 1 ]) is dict : res . append ( \"\" ) res [ - 1 ] = res [ - 1 ] + str ( n ) #append to previos string if exists #for i, x in enumerate(res): # if type(x) is str: res[i] = x.strip() #remove whitespace res = [ x for x in res if x and not ( type ( x ) is str and x . isspace ())] if t_count == 0 : res = text values = str ( text ) . strip () . split ( ';' ) if array_mode == 'force' : res = values elif array_mode == 'only_multiple' and len ( values ) > 1 : res = values elif array_mode == 'separator_present' and ';' in text : res = values return res","title":"create_flat_content_structure_from_wikitext()"},{"location":"tools/#wiki_tools.create_or_overwrite_wiki_page","text":"Creates a page with the passed title and content. If the page already exists, the prior content is replaced with the passed content. Parameters: Name Type Description Default title str Title of the wiki page, e. g. User:Someone1234 required content str required site mwclient . client . Site Site object from mwclient lib required Returns: Name Type Description success bool Source code in src/wiki_tools.py 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 def create_or_overwrite_wiki_page ( title , content , site ): \"\"\"Creates a page with the passed title and content. If the page already exists, the prior content is replaced with the passed content. Parameters ---------- title : str Title of the wiki page, e. g. User:Someone1234 content : str site : mwclient.client.Site Site object from mwclient lib Returns ------- success : bool \"\"\" target_page = site . pages [ title ] target_page . edit ( content , '[bot] create page' ) success = True return success","title":"create_or_overwrite_wiki_page()"},{"location":"tools/#wiki_tools.create_or_update_wiki_page_with_template","text":"Creates a wiki page with a template included in the content. If the page does already exist, the parameters within the template are update Parameters: Name Type Description Default title str Title of the wiki page, e. g. User:Someone1234 required content str required site mwclient . client . Site Site object from mwclient lib required overwrite_with_empty bool Decided whether a template parameter's value in an preexisting page is overwritten with an empty value False Returns: Name Type Description success bool Source code in src/wiki_tools.py 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 def create_or_update_wiki_page_with_template ( title , content , site , overwrite_with_empty = False ): \"\"\"Creates a wiki page with a template included in the content. If the page does already exist, the parameters within the template are update Parameters ---------- title : str Title of the wiki page, e. g. User:Someone1234 content : str site : mwclient.client.Site Site object from mwclient lib overwrite_with_empty : bool Decided whether a template parameter's value in an preexisting page is overwritten with an empty value Returns ------- success : bool \"\"\" search_result = search_wiki_page ( title , site ) if search_result [ \"Result\" ]: existing_page = site . pages [ title ] existing_text = existing_page . text () # update the page's content (template only) updated_content = update_template_within_wikitext ( text = existing_text , template_text = content , overwrite_with_empty = overwrite_with_empty ) success = create_or_overwrite_wiki_page ( title , updated_content , site ) else : # just create the page success = create_or_overwrite_wiki_page ( title , content , site ) return success","title":"create_or_update_wiki_page_with_template()"},{"location":"tools/#wiki_tools.create_site_object","text":"Parameters ---------- domain : str password_file : str (path to file with <username> ) Returns ------- site : mwclient.client.Site Site object from mwclient lib Source code in src/wiki_tools.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def create_site_object ( domain , password_file = \"\" ): \"\"\" Parameters ---------- domain : str password_file : str (path to file with <username>\\n<password>) Returns ------- site : mwclient.client.Site Site object from mwclient lib \"\"\" domain_dict = { \"wiki-dev\" : { \"Address\" : \"wiki-dev.open-semantic-lab.org\" } } if domain in domain_dict . keys (): domain = domain_dict [ domain ][ \"Address\" ] site = mwclient . Site ( domain , path = '/w/' ) if ( password_file != \"\" ): f = open ( password_file , \"r\" ) lines = f . readlines () user = lines [ 0 ] . strip () password = lines [ 1 ] . strip () f . close () else : user = input ( \"Enter bot username (username@botname)\" ) password = getpass . getpass ( \"Enter bot password\" ) site . login ( user , password ) del user del password return site","title":"create_site_object()"},{"location":"tools/#wiki_tools.delete_wiki_page","text":"Deletes the wiki page with the passed title, if it was found (exact match!), otherwise returns False Parameters: Name Type Description Default title str Title of the wiki page, e. g. User:Someone1234 required site mwclient . client . Site Site object from mwclient lib required reason str required Returns: Name Type Description success bool Source code in src/wiki_tools.py 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 def delete_wiki_page ( title , site , reason ): \"\"\"Deletes the wiki page with the passed title, if it was found (exact match!), otherwise returns False Parameters ---------- title : str Title of the wiki page, e. g. User:Someone1234 site : mwclient.client.Site Site object from mwclient lib reason : str Returns ------- success : bool \"\"\" try : page = site . pages [ title ] page . delete ( reason = reason , watch = False , unwatch = True , oldimage = False ) success = True except mwclient . errors . APIError : success = False return success","title":"delete_wiki_page()"},{"location":"tools/#wiki_tools.edit_wiki_page_with_content_merge","text":"Edits an existing wiki page, while merging the passed new content with the content of the existing page Parameters: Name Type Description Default title str Title of the wiki page, e. g. User:Someone1234 required new_content str required site mwclient . client . Site Site object from mwclient lib required template_name str required Returns: Name Type Description success bool Source code in src/wiki_tools.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 def edit_wiki_page_with_content_merge ( title , new_content , site , template_name ): \"\"\"Edits an existing wiki page, while merging the passed new content with the content of the existing page Parameters ---------- title : str Title of the wiki page, e. g. User:Someone1234 new_content : str site : mwclient.client.Site Site object from mwclient lib template_name : str Returns ------- success : bool \"\"\" search_result = search_wiki_page ( title , site ) if search_result [ \"Result\" ]: source_page = site . pages [ title ] source_page_content = source_page . text () # todo: test function new_content = merge_wiki_page_text ( new_content , source_page_content , template_name = template_name ) target_page = site . pages [ title ] target_page . edit ( new_content , '[bot] update of page content' ) success = True else : success = False return success","title":"edit_wiki_page_with_content_merge()"},{"location":"tools/#wiki_tools.extend_page_list_with_recursive_dependencies","text":"Finds all included templates, properties and categories for a list of wiki pages and appends them to the list Parameters: Name Type Description Default page_list list or iterable List of pages required site mwclient . client . Site Site object from mwclient lib required Returns: Name Type Description page_list list Source code in src/wiki_tools.py 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 def extend_page_list_with_recursive_dependencies ( page_list , site ): \"\"\"Finds all included templates, properties and categories for a list of wiki pages and appends them to the list Parameters ---------- page_list : list or iterable List of pages site : mwclient.client.Site Site object from mwclient lib Returns ------- page_list : list \"\"\" page_list_iter = copy . deepcopy ( page_list ) for page in page_list_iter : # we provide the updates page list to prevent a revisit of the pages dependencies = find_dependencies_recursively ( page , site , dependencies = page_list , debug = False ) page_list . extend ( dependencies ) page_list = np . unique ( page_list ) return page_list","title":"extend_page_list_with_recursive_dependencies()"},{"location":"tools/#wiki_tools.find_dependencies","text":"Finds templates, properties and categories within wikitext Parameters: Name Type Description Default wikitext str required debug bool Whether to print debugging messages False Returns: Name Type Description filtered_dependencies list Source code in src/wiki_tools.py 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 def find_dependencies ( wikitext , debug = False ): \"\"\"Finds templates, properties and categories within wikitext Parameters ---------- wikitext : str debug : bool Whether to print debugging messages Returns ------- filtered_dependencies : list \"\"\" dependencies = [] code = mwparserfromhell . parse ( wikitext ) for template in code . filter_templates ( recursive = True ): if template . name . split ( ':' )[ 0 ] . isupper (): if debug : print ( \"MagicWord: {} \" . format ( template . name )) elif template . name [ 0 ] == \"#\" : if debug : print ( \"ParserFunction: {} \" . format ( template . name )) if \"#set:\" in template . name or \"#declare:\" in template . name : if '=' in template . name . split ( ':' )[ 1 ]: # in case of '{{#set:HasIdPostfix={{{id_postfix}}} }}' property_ = \"Property:\" + template . name . split ( ':' )[ 1 ] . split ( '=' )[ 0 ] dependencies . append ( property_ ) if debug : print ( \"=> {} \" . format ( property_ )) for param in template . params : property_ = \"Property:\" + param . split ( '=' )[ 0 ] dependencies . append ( property_ ) if debug : print ( \"=> {} \" . format ( property_ )) else : if debug : print ( \"Template: {} \" . format ( template . name )) template_name = str ( template . name ) if ':' not in template . name : template_name = \"Template:\" + template_name dependencies . append ( template_name ) if debug : print ( \"=> {} \" . format ( template_name )) # for tag in code.filter_tags(recursive=True): # if (debug): print(\"Tag: {}\".format(tag)) for link in code . filter_wikilinks ( recursive = True ): if '::' in link : if debug : print ( \"Annotation: {} \" . format ( link )) property_ = \"Property:\" + link . split ( '::' )[ 0 ] . split ( '[[' )[ - 1 ] dependencies . append ( property_ ) if debug : print ( \"=> {} \" . format ( property_ )) if 'Category:' in link : if debug : print ( \"Category: {} \" . format ( link )) category = link . replace ( '[[' , '' ) . replace ( ']]' , '' ) dependencies . append ( str ( category )) if debug : print ( \"=> {} \" . format ( category )) else : if debug : print ( \"Link: {} \" . format ( link )) dependencies = np . unique ( dependencies ) . tolist () # remove duplicates filtered_dependencies = [] # do not manipulate the iterated object for dependency in dependencies : # ensure no leading or trailing white spaces dependency = dependency . strip () # very frew page titles listed here contain invalid characters \"\\n\" dependency = dependency . replace ( ' \\n ' , '' ) # see https://www.semantic-mediawiki.org/wiki/Help:Special_properties if 'Property:' in dependency and ( ' ' in dependency or '_' in dependency ): if debug : print ( \"Info: Remove presumptive built-in property {} \" . format ( dependency )) else : filtered_dependencies . append ( dependency ) return filtered_dependencies","title":"find_dependencies()"},{"location":"tools/#wiki_tools.find_dependencies_recursively","text":"Finds all included templates, properties and categories within a wiki page Parameters: Name Type Description Default title str Title of the wiki page, e. g. User:Someone1234 required site mwclient . client . Site Site object from mwclient lib required dependencies List of already found dependent titles [] debug bool Whether to print debugging messages False Returns: Name Type Description dependencies list Source code in src/wiki_tools.py 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 def find_dependencies_recursively ( title , site , dependencies = [], debug = False ): \"\"\"Finds all included templates, properties and categories within a wiki page Parameters ---------- title : str Title of the wiki page, e. g. User:Someone1234 site : mwclient.client.Site Site object from mwclient lib dependencies List of already found dependent titles debug : bool Whether to print debugging messages Returns ------- dependencies : list \"\"\" title = title . replace ( \"{\" , \"\" ) . replace ( \"}\" , \"\" ) page = site . pages [ title ] content = page . text () new_dependencies = find_dependencies ( content , debug ) for dependency in new_dependencies : if dependency not in dependencies : # for circular dependencies dependencies . append ( dependency ) if debug : print ( \"Scan nested {} \" . format ( dependency )) find_dependencies_recursively ( dependency , site , dependencies = dependencies , debug = debug ) return dependencies","title":"find_dependencies_recursively()"},{"location":"tools/#wiki_tools.get_wikitext_from_flat_content_dict","text":"Create wiki source text from a flat python dict representing a wiki template Parameters: Name Type Description Default d dict flat python dict e.g.: {\"HeaderTemplate\": {\"param\": \"value\"}} required Returns: Name Type Description wt str wiki text Source code in src/wiki_tools.py 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 def get_wikitext_from_flat_content_dict ( d : dict ): \"\"\"Create wiki source text from a flat python dict representing a wiki template Parameters ---------- d : dict flat python dict e.g.: {\"HeaderTemplate\": {\"param\": \"value\"}} Returns ------- wt : str wiki text \"\"\" wt = \"\" for key , value in d . items (): #print(\"key: {}, valuetype: {}, value: {}\".format(key, type(value), \"\")) if isinstance ( value , dict ): #print(\"dict\") wt += \"{{\" + key wt += get_wikitext_from_flat_content_dict ( value ) wt += \" \\n }}\" elif isinstance ( value , list ): #print(\"list\") wt += \" \\n | {} =\" . format ( key ) string_index = 0 for index , element in enumerate ( value ): if isinstance ( element , dict ): wt += get_wikitext_from_flat_content_dict ( element ) #wt += \"\\n{{\" + element #wt += get_wikitext_from_dict(element) #wt += \"\\n}}\" else : if ( string_index != index ): print ( f \"Warning: template param ' { key } ' has mixed template/string values: { value } \" ) if string_index > 0 and element and not element . strip () . isspace (): wt += \";\" wt += element string_index += 1 else : #print(\"literal\") wt += \" \\n | {} = {} \" . format ( key , value ) return wt","title":"get_wikitext_from_flat_content_dict()"},{"location":"tools/#wiki_tools.get_wikitext_from_flat_content_structure","text":"Create wiki source text from the content list (aka 'flat_content_structure' = 'wikiJson') of the page Parameters: Name Type Description Default content list content list, mixed objects (templates) and free text (aka 'flat_content_structure' = 'wikiJson') e.g.: [{\"HeaderTemplate\": {\"param\": \"value\"}}, \"freetext\", {\"FooterTemplate\": {\"param2\": \"value\"}}] required Returns: Name Type Description wt wiki text Source code in src/wiki_tools.py 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 def get_wikitext_from_flat_content_structure ( content ): \"\"\"Create wiki source text from the content list (aka 'flat_content_structure' = 'wikiJson') of the page Parameters ---------- content : list content list, mixed objects (templates) and free text (aka 'flat_content_structure' = 'wikiJson') e.g.: [{\"HeaderTemplate\": {\"param\": \"value\"}}, \"freetext\", {\"FooterTemplate\": {\"param2\": \"value\"}}] Returns ------- wt : wiki text \"\"\" wt = \"\" for content_element in content : if isinstance ( content_element , dict ): wt += get_wikitext_from_flat_content_dict ( content_element ) elif isinstance ( content_element , str ): wt += content_element #\"\\n\" + content_element else : print ( \"Error: content element is not dict or string: {} \" . format ( content_element )) return wt","title":"get_wikitext_from_flat_content_structure()"},{"location":"tools/#wiki_tools.merge_wiki_page_text","text":"Not fully tested function! Parameters: Name Type Description Default text1 required text2 required template_name required subtemplate_param '' subtemplate_name '' Returns: Name Type Description non_empty_lines str Source code in src/wiki_tools.py 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 def merge_wiki_page_text ( text1 , text2 , template_name , subtemplate_param = \"\" , subtemplate_name = \"\" ): \"\"\"Not fully tested function! Parameters ---------- text1 text2 template_name subtemplate_param subtemplate_name Returns ------- non_empty_lines : str \"\"\" if text1 == text2 : return text1 if text1 == \"\" : return text2 if text2 == \"\" : return text1 code1 = mwparserfromhell . parse ( text1 ) code2 = mwparserfromhell . parse ( text2 ) r1 = [] r2 = [] for template in code1 . filter_templates ( recursive = True ): if template . name . matches ( template_name ): t1 = template if template . name . matches ( subtemplate_name ): r1 . append ( template ) for template in code2 . filter_templates ( recursive = True ): if template . name . matches ( template_name ): t2 = template if template . name . matches ( subtemplate_name ): r2 . append ( template ) # print(\"T1: \" + str(t1)) # print(\"T2: \" + str(t2)) for p in t2 . params : if not t1 . has ( p . name ): t1 . add ( p . name , p . value ) if subtemplate_param != \"\" : t1 . remove ( subtemplate_param ) for rel2 in r2 : exists = False for rel1 in r1 : all_params_equal = True for p in rel2 . params : if rel1 . has ( p . name ): if not rel1 . get ( p . name ) . value . matches ( rel2 . get ( p . name ) . value ): all_params_equal = False # print(\"Compare {}:{} with :{} -> res={}\".format(p.name, rel1.get(p.name).value,rel2.get(p.name).value, # rel1.get(p.name).value.matches(rel2.get(p.name).value))) else : all_params_equal = False if all_params_equal : exists = True if not exists : r1 . append ( rel2 ) r1string = \"\" for rel1 in r1 : r1string += \" \\r\\n \" + str ( rel1 ) t1 . add ( subtemplate_param , r1string ) # print(\"Tmerged: \" + str(t1)) non_empty_lines = \" \\n \" . join ([ ll . rstrip () for ll in str ( t1 ) . splitlines () if ll . strip ()]) return non_empty_lines","title":"merge_wiki_page_text()"},{"location":"tools/#wiki_tools.prefix_search","text":"Parameters: Name Type Description Default site mwclient . client . Site Site object from mwclient lib required text str required Returns: Name Type Description page_list list Source code in src/wiki_tools.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def prefix_search ( site , text ): \"\"\" Parameters ---------- site : mwclient.client.Site Site object from mwclient lib text : str Returns ------- page_list : list \"\"\" page_list = [] result = site . api ( 'query' , list = \"prefixsearch\" , pssearch = text , pslimit = 1000 , format = 'json' ) if len ( result [ 'query' ][ 'prefixsearch' ]) == 0 : print ( 'No results' ) else : for page in result [ 'query' ][ 'prefixsearch' ]: title = page [ 'title' ] print ( title ) page_list . append ( title ) return page_list","title":"prefix_search()"},{"location":"tools/#wiki_tools.schemaJson2WikiJson","text":"Create content representation of a page (aka 'flat_content_structure' = 'wikiJson') from the osl schema-compatible json Parameters: Name Type Description Default schemaJson dict schema-compatible json e.g.: {osl_template: \"HeaderTemplate\", \"param\": \"value\", \"osl_wikitext\": \"freetext\", \"osl_footer\": {\"osl_template\": \"FooterTemplate\", \"param2\": \"value2\"}} required isRoot: boolean indicates first call in recursion Returns: Name Type Description wikiJson list content list, mixed objects (templates) and free text (aka 'flat_content_structure' = 'wikiJson') e.g.: [{\"HeaderTemplate\": {\"param\": \"value\"}}, \"freetext\", {\"FooterTemplate\": {\"param2\": \"value\"}}] Source code in src/wiki_tools.py 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 def schemaJson2WikiJson ( schemaJson , isRoot = True ): \"\"\"Create content representation of a page (aka 'flat_content_structure' = 'wikiJson') from the osl schema-compatible json Parameters ---------- schemaJson : dict schema-compatible json e.g.: {osl_template: \"HeaderTemplate\", \"param\": \"value\", \"osl_wikitext\": \"freetext\", \"osl_footer\": {\"osl_template\": \"FooterTemplate\", \"param2\": \"value2\"}} isRoot: boolean indicates first call in recursion Returns ------- wikiJson : list content list, mixed objects (templates) and free text (aka 'flat_content_structure' = 'wikiJson') e.g.: [{\"HeaderTemplate\": {\"param\": \"value\"}}, \"freetext\", {\"FooterTemplate\": {\"param2\": \"value\"}}] \"\"\" wikiJson = [{}, \"\" , {}]; #header, freetext, footer template = \"\" footer_template = \"\" if 'osl_template' in schemaJson : template = schemaJson [ 'osl_template' ] wikiJson [ 0 ][ template ] = {} else : print ( \"Error: Mandatory property 'osl_template' not found in schemaJson\" , schemaJson ) return if 'osl_wikitext' in schemaJson : wikiJson [ 1 ] = schemaJson [ 'osl_wikitext' ] if 'osl_footer' in schemaJson : wikiJson [ 2 ] = schemaJson2WikiJson ( schemaJson [ 'osl_footer' ], False )[ 0 ] footer_template = schemaJson [ 'osl_footer' ][ 'osl_template' ] wikiJson [ 2 ][ footer_template ][ 'extensions' ] = [] for key in schemaJson : if key . startswith ( '_' ) or key . startswith ( 'osl_template' ) or key . startswith ( 'osl_wikitext' ) or key . startswith ( 'osl_footer' ): continue #exclude private and reserved keywords if schemaJson [ key ] == None : continue if isinstance ( schemaJson [ key ], list ): wikiJson [ 0 ][ template ][ key ] = [] for subSchemaJson in schemaJson [ key ]: subWikiJson = schemaJson2WikiJson ( subSchemaJson , False ) wikiJson [ 0 ][ template ][ key ] . append ( subWikiJson [ 0 ]) if ( key == \"extensions\" ): wikiJson [ 2 ][ footer_template ][ 'extensions' ] . append ( subWikiJson [ 2 ]) elif isinstance ( schemaJson [ key ], dict ): subWikiJson = schemaJson2WikiJson ( subSchemaJson , False ) wikiJson [ 0 ][ template ][ key ] = subWikiJson [ 0 ] else : wikiJson [ 0 ][ template ][ key ] = schemaJson [ key ] return wikiJson","title":"schemaJson2WikiJson()"},{"location":"tools/#wiki_tools.search_redirection_sources","text":"Returns a list of pages redirecting to the page with target_title per #REDIRECT [[target]] syntax Parameters: Name Type Description Default site mwclient . client . Site Site object from mwclient lib required target_title str Title of the target wiki page required Returns: Name Type Description page_list list of pages redirecting to the page with target_title Source code in src/wiki_tools.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def search_redirection_sources ( site , target_title , debug = False ): \"\"\"Returns a list of pages redirecting to the page with target_title per #REDIRECT [[target]] syntax Parameters ---------- site : mwclient.client.Site Site object from mwclient lib target_title : str Title of the target wiki page Returns ------- page_list : list of pages redirecting to the page with target_title \"\"\" page_list = [] result = site . api ( 'query' , titles = target_title , prop = 'redirects' , format = 'json' ) if len ( result [ 'query' ][ 'pages' ]) == 0 : if ( debug ): print ( 'No results' ) else : for page in result [ 'query' ][ 'pages' ]: if not 'redirects' in result [ 'query' ][ 'pages' ][ page ]: if ( debug ): print ( 'No results' ) else : for redirecting_source in result [ 'query' ][ 'pages' ][ page ][ 'redirects' ]: title = redirecting_source [ 'title' ] page_list . append ( title ) return page_list","title":"search_redirection_sources()"},{"location":"tools/#wiki_tools.search_wiki_page","text":"Adds exact match functionality with ignore-case on top of the prefix_search()'s functionality Parameters: Name Type Description Default title str Title of the wiki page, e. g. User:Someone1234 required site mwclient . client . Site Site object from mwclient lib required Returns: Name Type Description result_dict dict Source code in src/wiki_tools.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def search_wiki_page ( title , site ): \"\"\"Adds exact match functionality with ignore-case on top of the prefix_search()'s functionality Parameters ---------- title : str Title of the wiki page, e. g. User:Someone1234 site : mwclient.client.Site Site object from mwclient lib Returns ------- result_dict : dict \"\"\" result = site . api ( 'query' , list = \"prefixsearch\" , pssearch = title , pslimit = 1000 , format = 'json' ) if len ( result [ 'query' ][ 'prefixsearch' ]) == 0 : return { \"Result\" : False , \"List\" : list ()} else : exact_match = False page_title_list = list () for page in result [ 'query' ][ 'prefixsearch' ]: page_title = page [ 'title' ] page_title_list . append ( page_title ) if page_title . lower () == title . lower (): exact_match = True result_dict = { \"Result\" : True , \"List\" : page_title_list , \"Exact match\" : exact_match } return result_dict","title":"search_wiki_page()"},{"location":"tools/#wiki_tools.semantic_search","text":"Parameters: Name Type Description Default site mwclient . client . Site Site object from mwclient lib required query required Returns: Name Type Description page_list list Source code in src/wiki_tools.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 def semantic_search ( site , query ): \"\"\" Parameters ---------- site : mwclient.client.Site Site object from mwclient lib query Returns ------- page_list : list \"\"\" page_list = [] query += \"|limit=1000\" result = site . api ( 'ask' , query = query , format = 'json' ) if len ( result [ 'query' ][ 'results' ]) == 0 : print ( \"Query ' {} ' returned no results\" . format ( query )) else : print ( \"Query ' {} ' returned {} results\" . format ( query , len ( result [ 'query' ][ 'results' ]))) for page in result [ 'query' ][ 'results' ] . values (): # why do we do the following? if 'printouts' in page : title = page [ 'fulltext' ] if '#' not in title : print ( title ) # original position of \"page_list.append(title)\" line page_list . append ( title ) return page_list","title":"semantic_search()"},{"location":"tools/#wiki_tools.update_template_within_wikitext","text":"Updates the template parameters in an existing wiki with a provided new Parameters: Name Type Description Default text str The existing text required template_text str The template text with new data required delete bool If true, params not defined in get removed from False remove_empty_lines bool If true, function will cleanup empty lines within the template code created by the underlying mwparserfromhell lib (wanted), but also within the wiki text around it (unwanted) False overwrite_with_empty bool If true, parameters in the existing tempalte will be overwritten even if the parameter value in the template_text is empty False Returns: Name Type Description new_text str Source code in src/wiki_tools.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 def update_template_within_wikitext ( text , template_text , delete = False , remove_empty_lines = False , overwrite_with_empty = False ): \"\"\"Updates the template parameters in an existing wiki <text> with a provided new <template_text> Parameters ---------- text : str The existing text template_text : str The template text with new data delete : bool If true, params not defined in <template_text> get removed from <text> remove_empty_lines : bool If true, function will cleanup empty lines within the template code created by the underlying mwparserfromhell lib (wanted), but also within the wiki text around it (unwanted) overwrite_with_empty : bool If true, parameters in the existing tempalte will be overwritten even if the parameter value in the template_text is empty Returns ------- new_text : str \"\"\" if template_text == text : return template_text if template_text == \"\" : return text if text == \"\" : return template_text new_code = mwparserfromhell . parse ( template_text ) new_template = new_code . filter_templates ()[ 0 ] existing_code = mwparserfromhell . parse ( text ) template_names_matched = False for template in existing_code . filter_templates ( recursive = True ): if template . name . matches ( new_template . name ): existing_template = template template_names_matched = True break if template_names_matched : for p in new_template . params : if existing_template . has ( p . name ): if p . value != \"\" or overwrite_with_empty : existing_template . get ( p . name ) . value = p . value else : existing_template . add ( p . name , p . value ) if delete : for p in existing_template . params : if not new_template . has ( p . name ): existing_template . remove ( p ) else : # the original text did not contain a matching template # options: 1) include the new template # 2) replace the existing template - but what if multiple tempaltes exist on that page? pass # print(\"Tmerged: \\n\" + str(existing_template)) # print(\"Text merged: \" + str(existing_code)) new_text = str ( existing_code ) # this will cleanup empty lines within the template code (wanted), but also within the wiki text around it (unwanted) if remove_empty_lines : new_text = \" \\n \" . join ([ ll . rstrip () for ll in str ( new_text ) . splitlines () if ll . strip ()]) return new_text","title":"update_template_within_wikitext()"},{"location":"tools/#wiki_tools.wikiJson2SchemaJson","text":"Create osl schema-compatible json from the content representation of a page (aka 'flat_content_structure' = 'wikiJson') Parameters: Name Type Description Default wikiJson list content list, mixed objects (templates) and free text (aka 'flat_content_structure' = 'wikiJson') e.g.: [{\"HeaderTemplate\": {\"param\": \"value\"}}, \"freetext\", {\"FooterTemplate\": {\"param2\": \"value\"}}] required Returns: Name Type Description schemaJson dict schema-compatible json e.g.: {osl_template: \"HeaderTemplate\", \"param\": \"value\", \"osl_wikitext\": \"freetext\", \"osl_footer\": {\"osl_template\": \"FooterTemplate\", \"param2\": \"value2\"}} Source code in src/wiki_tools.py 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 def wikiJson2SchemaJson ( schema , wikiJson ): \"\"\"Create osl schema-compatible json from the content representation of a page (aka 'flat_content_structure' = 'wikiJson') Parameters ---------- wikiJson : list content list, mixed objects (templates) and free text (aka 'flat_content_structure' = 'wikiJson') e.g.: [{\"HeaderTemplate\": {\"param\": \"value\"}}, \"freetext\", {\"FooterTemplate\": {\"param2\": \"value\"}}] Returns ------- schemaJson : dict schema-compatible json e.g.: {osl_template: \"HeaderTemplate\", \"param\": \"value\", \"osl_wikitext\": \"freetext\", \"osl_footer\": {\"osl_template\": \"FooterTemplate\", \"param2\": \"value2\"}} \"\"\" schemaJson = {} if not isinstance ( wikiJson [ 0 ], dict ) or not isinstance ( wikiJson [ 1 ], str ) or not isinstance ( wikiJson [ 2 ], dict ): print ( \"Error: Invalid wikiJson:\" , wikiJson ) return schemaJson schemaJson = wikiJson2SchemaJsonRecursion ( schema , wikiJson [ 0 ], wikiJson [ 2 ]) schemaJson [ \"osl_wikitext\" ] = wikiJson [ 1 ] return schemaJson","title":"wikiJson2SchemaJson()"},{"location":"tools/#wiki_tools.wikiJson2SchemaJsonRecursion","text":"internal recursion function of wikiJson2SchemaJson() Parameters: Name Type Description Default wikiJson list wiki template representation e.g.: {\"HeaderTemplate\": {\"param\": \"value\"}} required footerWikiJson : list wiki footer template representation e.g.: {\"FooterTemplate\": {\"param2\": \"value2\"}} Returns: Name Type Description schemaJson dict schema-compatible json e.g.: {osl_template: \"HeaderTemplate\", \"param\": \"value\", \"osl_footer\": {\"osl_template\": \"FooterTemplate\", \"param2\": \"value2\"}} Source code in src/wiki_tools.py 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 def wikiJson2SchemaJsonRecursion ( schema : dict , wikiJson : dict , footerWikiJson = None ): \"\"\"internal recursion function of wikiJson2SchemaJson() Parameters ---------- wikiJson : list wiki template representation e.g.: {\"HeaderTemplate\": {\"param\": \"value\"}} footerWikiJson : list wiki footer template representation e.g.: {\"FooterTemplate\": {\"param2\": \"value2\"}} Returns ------- schemaJson : dict schema-compatible json e.g.: {osl_template: \"HeaderTemplate\", \"param\": \"value\", \"osl_footer\": {\"osl_template\": \"FooterTemplate\", \"param2\": \"value2\"}} \"\"\" schemaJson = {} if footerWikiJson != None : schemaJson [ 'osl_footer' ] = wikiJson2SchemaJsonRecursion ( schema , footerWikiJson ) for key in wikiJson : value = wikiJson [ key ] if isinstance ( value , list ): schemaJson [ key ] = [] for index , element in enumerate ( value ): element = value [ index ] if isinstance ( element , dict ): if key == \"extensions\" : if footerWikiJson != None : #we asume that every extension provides also a footer template nextFooter = footerWikiJson [ schemaJson [ 'osl_footer' ][ 'osl_template' ]][ 'extensions' ][ index ] schemaJson [ key ] . append ( wikiJson2SchemaJsonRecursion ( schema , element , nextFooter )) else : schemaJson [ key ] . append ( wikiJson2SchemaJsonRecursion ( schema , element )) else : schemaJson [ key ] . append ( element ) elif isinstance ( value , dict ): schemaJson = wikiJson2SchemaJsonRecursion ( schema , value , footerWikiJson ) schemaJson [ 'osl_template' ] = key else : schemaJson [ key ] = value if 'osl_template' in schemaJson : jsonpath_expr = parse ( '$..properties' ) #[?osl_template.default = \"' + schemaJson['osl_template'] + '\"]') schema_def = {} #print(\"Search for \", schemaJson['osl_template']) for match in jsonpath_expr . find ( schema ): value = match . value if value [ 'osl_template' ][ 'default' ] == schemaJson [ 'osl_template' ]: schema_def = match . value #print(schema_def) for key in list ( schemaJson . keys ()): if key in schema_def and 'type' in schema_def [ key ]: #use schema to resolve types if schema_def [ key ][ 'type' ] == 'integer' : schemaJson [ key ] = int ( schemaJson [ key ]) elif schema_def [ key ][ 'type' ] == 'float' : schemaJson [ key ] = float ( schemaJson [ key ]) elif schema_def [ key ][ 'type' ] == 'number' : schemaJson [ key ] = float ( schemaJson [ key ]) elif schema_def [ key ][ 'type' ] == 'string' : schemaJson [ key ] = str ( schemaJson [ key ]) elif schema_def [ key ][ 'type' ] == 'array' : if not isinstance ( schemaJson [ key ], list ): del schemaJson [ key ] elif len ( schemaJson [ key ]) == 0 : del schemaJson [ key ] else : #fall back if schemaJson [ key ] == \"\" and key == 'extensions' : del schemaJson [ key ] elif isinstance ( schemaJson [ key ], list ): #wikiJson defaults are lists, even for single or empty values if len ( schemaJson [ key ]) == 0 : del schemaJson [ key ] #elif len(schemaJson[key]) == 1: schemaJson[key] = schemaJson[key][0] return schemaJson","title":"wikiJson2SchemaJsonRecursion()"}]}