{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"osw","text":"<p>Python toolset for data processing, queries, wikicode generation and page manipulation</p>"},{"location":"#note","title":"Note","text":"<p>This is the main page of your project's Sphinx documentation. It is formatted in Markdown. Add additional pages by creating md-files in <code>docs</code> or rst-files (formatted in reStructuredText) and adding links to them in the <code>Contents</code> section below.</p> <p>Please check Sphinx and MyST for more information about how to document your project and how to configure your preferences.</p>"},{"location":"#contents","title":"Contents","text":"<pre><code>:maxdepth: 2\n\nOverview &lt;readme&gt;\nContributions &amp; Help &lt;contributing&gt;\nLicense &lt;license&gt;\nAuthors &lt;authors&gt;\nChangelog &lt;changelog&gt;\nModule Reference &lt;api/modules&gt;\n</code></pre>"},{"location":"#indices-and-tables","title":"Indices and tables","text":"<ul> <li>{ref}<code>genindex</code></li> <li>{ref}<code>modindex</code></li> <li>{ref}<code>search</code></li> </ul>"},{"location":"auth/","title":"Auth","text":"<p>Authentication</p>"},{"location":"auth/#credentialmanager","title":"CredentialManager","text":"<p>             Bases: <code>OswBaseModel</code></p> <p>Handles credentials</p> Source code in <code>src/osw/auth.py</code> <pre><code>class CredentialManager(OswBaseModel):\n\"\"\"Handles credentials\"\"\"\n\n    cred_filepath: Optional[Union[Union[str, FilePath], List[Union[str, FilePath]]]]\n\"\"\"Filepath to yaml file with credentials for osw and connected services\"\"\"\n    cert_filepath: Optional[Union[Union[str, FilePath], List[Union[str, FilePath]]]]\n\"\"\"Filepath to the certificates for osw and connected services\"\"\"\n\n    _credentials: List[BaseCredential] = PrivateAttr([])\n\"\"\"in memory credential store\"\"\"\n\n    class BaseCredential(OswBaseModel):\n\"\"\"Abstract base class for credentials\"\"\"\n\n        iri: str\n\"\"\"the iri the credential is valid for\"\"\"\n\n    class UserPwdCredential(BaseCredential):\n\"\"\"a username - password credential\"\"\"\n\n        username: str\n\"\"\"the user identifier\"\"\"\n        password: str\n\"\"\"the users password\"\"\"\n\n    class OAuth1Credential(BaseCredential):\n\"\"\"OAuth1 credentials. See https://requests-oauthlib.readthedocs.io/en/latest/oauth1_workflow.html\"\"\"\n\n        consumer_token: str\n\"\"\"consumer token\"\"\"\n        consumer_secret: str\n\"\"\"consumer secret \"\"\"\n        access_token: str\n\"\"\"access token\"\"\"\n        access_secret: str\n\"\"\"access secret\"\"\"\n\n    class CredentialFallback(Enum):\n\"\"\"Modes of handling missing credentials\n\n        Attributes\n        ----------\n        none:\n            throw error\n        ask:\n            use getpass to ask for credentials\n        \"\"\"\n\n        ask = \"ask\"  # use getpass to ask for credentials\n        none = \"none\"  # throw error\n\n    class CredentialConfig(OswBaseModel):\n\"\"\"Reads credentials from a yaml file\"\"\"\n\n        iri: str\n\"\"\"internationalized resource identifier / address of the service, may contain protocol, domain, port and path\n            matches by \"contains\" returning the shortest match\"\"\"\n        fallback: Optional[CredentialManager.CredentialFallback] = \"none\"\n\"\"\"The fallback strategy if no credential was found for the given origin\"\"\"\n\n    def get_credential(self, config: CredentialConfig) -&gt; BaseCredential:\n\"\"\"Reads credentials from a yaml file or the in memory store\n\n        Parameters\n        ----------\n        config:\n            see CredentialConfig\n\n        Returns\n        -------\n        credential :\n            Credential, contain attributes 'username' and 'password' and the matching iri.\n        \"\"\"\n\n        _file_credentials: List[CredentialManager.BaseCredential] = []\n        if self.cred_filepath:\n            filepaths = self.cred_filepath\n            if type(filepaths) is not list:\n                filepaths = [filepaths]\n\n            for filepath in filepaths:\n                if filepath != \"\":\n                    with open(filepath, \"r\") as stream:\n                        try:\n                            accounts = yaml.safe_load(stream)\n                            for iri in accounts.keys():\n                                if (\n                                    \"username\" in accounts[iri]\n                                    and \"password\" in accounts[iri]\n                                ):\n                                    cred = CredentialManager.UserPwdCredential(\n                                        username=accounts[iri][\"username\"],\n                                        password=accounts[iri][\"password\"],\n                                        iri=iri,\n                                    )\n                                    _file_credentials.append(cred)\n                                if (\n                                    \"consumer_token\" in accounts[iri]\n                                    and \"consumer_secret\" in accounts[iri]\n                                    and \"access_token\" in accounts[iri]\n                                    and \"access_secret\" in accounts[iri]\n                                ):\n                                    cred = CredentialManager.OAuth1Credential(\n                                        consumer_token=accounts[iri][\"consumer_token\"],\n                                        consumer_secret=accounts[iri][\n                                            \"consumer_secret\"\n                                        ],\n                                        access_token=accounts[iri][\"access_token\"],\n                                        access_secret=accounts[iri][\"access_secret\"],\n                                        iri=iri,\n                                    )\n                                    _file_credentials.append(cred)\n                        except yaml.YAMLError as exc:\n                            print(exc)\n\n        match_iri = \"\"\n        cred = None\n        creds = _file_credentials + self._credentials\n        for _cred in creds:\n            iri = _cred.iri\n            if config.iri in iri:\n                if match_iri == \"\" or len(match_iri) &gt; len(\n                    iri\n                ):  # use the less specific match\n                    match_iri = iri\n                    cred = _cred\n\n        if cred is None:\n            if config.fallback is CredentialManager.CredentialFallback.ask:\n                print(\n                    f\"No credentials for {config.iri} found. Please use the prompt to login\"\n                )\n                username = input(\"Enter username: \")\n                password = getpass.getpass(\"Enter password: \")\n                cred = CredentialManager.UserPwdCredential(\n                    username=username, password=password, iri=config.iri\n                )\n        return cred\n\n    def add_credential(self, cred: BaseCredential):\n\"\"\"adds a credential to the in memory store\n\n        Parameters\n        ----------\n        cred\n            the credential to add\n        \"\"\"\n        self._credentials.append(cred)\n</code></pre>"},{"location":"auth/#osw.auth.CredentialManager.cert_filepath","title":"<code>cert_filepath: Optional[Union[Union[str, FilePath], List[Union[str, FilePath]]]]</code>  <code>instance-attribute</code>","text":"<p>Filepath to the certificates for osw and connected services</p>"},{"location":"auth/#osw.auth.CredentialManager.cred_filepath","title":"<code>cred_filepath: Optional[Union[Union[str, FilePath], List[Union[str, FilePath]]]]</code>  <code>instance-attribute</code>","text":"<p>Filepath to yaml file with credentials for osw and connected services</p>"},{"location":"auth/#osw.auth.CredentialManager.BaseCredential","title":"<code>BaseCredential</code>","text":"<p>             Bases: <code>OswBaseModel</code></p> <p>Abstract base class for credentials</p> Source code in <code>src/osw/auth.py</code> <pre><code>class BaseCredential(OswBaseModel):\n\"\"\"Abstract base class for credentials\"\"\"\n\n    iri: str\n\"\"\"the iri the credential is valid for\"\"\"\n</code></pre>"},{"location":"auth/#osw.auth.CredentialManager.BaseCredential.iri","title":"<code>iri: str</code>  <code>instance-attribute</code>","text":"<p>the iri the credential is valid for</p>"},{"location":"auth/#osw.auth.CredentialManager.CredentialConfig","title":"<code>CredentialConfig</code>","text":"<p>             Bases: <code>OswBaseModel</code></p> <p>Reads credentials from a yaml file</p> Source code in <code>src/osw/auth.py</code> <pre><code>class CredentialConfig(OswBaseModel):\n\"\"\"Reads credentials from a yaml file\"\"\"\n\n    iri: str\n\"\"\"internationalized resource identifier / address of the service, may contain protocol, domain, port and path\n        matches by \"contains\" returning the shortest match\"\"\"\n    fallback: Optional[CredentialManager.CredentialFallback] = \"none\"\n\"\"\"The fallback strategy if no credential was found for the given origin\"\"\"\n</code></pre>"},{"location":"auth/#osw.auth.CredentialManager.CredentialConfig.fallback","title":"<code>fallback: Optional[CredentialManager.CredentialFallback] = 'none'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The fallback strategy if no credential was found for the given origin</p>"},{"location":"auth/#osw.auth.CredentialManager.CredentialConfig.iri","title":"<code>iri: str</code>  <code>instance-attribute</code>","text":"<p>internationalized resource identifier / address of the service, may contain protocol, domain, port and path matches by \"contains\" returning the shortest match</p>"},{"location":"auth/#osw.auth.CredentialManager.CredentialFallback","title":"<code>CredentialFallback</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Modes of handling missing credentials</p> <p>Attributes:</p> Name Type Description <code>none</code> <p>throw error</p> <code>ask</code> <p>use getpass to ask for credentials</p> Source code in <code>src/osw/auth.py</code> <pre><code>class CredentialFallback(Enum):\n\"\"\"Modes of handling missing credentials\n\n    Attributes\n    ----------\n    none:\n        throw error\n    ask:\n        use getpass to ask for credentials\n    \"\"\"\n\n    ask = \"ask\"  # use getpass to ask for credentials\n    none = \"none\"  # throw error\n</code></pre>"},{"location":"auth/#osw.auth.CredentialManager.OAuth1Credential","title":"<code>OAuth1Credential</code>","text":"<p>             Bases: <code>BaseCredential</code></p> <p>OAuth1 credentials. See https://requests-oauthlib.readthedocs.io/en/latest/oauth1_workflow.html</p> Source code in <code>src/osw/auth.py</code> <pre><code>class OAuth1Credential(BaseCredential):\n\"\"\"OAuth1 credentials. See https://requests-oauthlib.readthedocs.io/en/latest/oauth1_workflow.html\"\"\"\n\n    consumer_token: str\n\"\"\"consumer token\"\"\"\n    consumer_secret: str\n\"\"\"consumer secret \"\"\"\n    access_token: str\n\"\"\"access token\"\"\"\n    access_secret: str\n\"\"\"access secret\"\"\"\n</code></pre>"},{"location":"auth/#osw.auth.CredentialManager.OAuth1Credential.access_secret","title":"<code>access_secret: str</code>  <code>instance-attribute</code>","text":"<p>access secret</p>"},{"location":"auth/#osw.auth.CredentialManager.OAuth1Credential.access_token","title":"<code>access_token: str</code>  <code>instance-attribute</code>","text":"<p>access token</p>"},{"location":"auth/#osw.auth.CredentialManager.OAuth1Credential.consumer_secret","title":"<code>consumer_secret: str</code>  <code>instance-attribute</code>","text":"<p>consumer secret</p>"},{"location":"auth/#osw.auth.CredentialManager.OAuth1Credential.consumer_token","title":"<code>consumer_token: str</code>  <code>instance-attribute</code>","text":"<p>consumer token</p>"},{"location":"auth/#osw.auth.CredentialManager.UserPwdCredential","title":"<code>UserPwdCredential</code>","text":"<p>             Bases: <code>BaseCredential</code></p> <p>a username - password credential</p> Source code in <code>src/osw/auth.py</code> <pre><code>class UserPwdCredential(BaseCredential):\n\"\"\"a username - password credential\"\"\"\n\n    username: str\n\"\"\"the user identifier\"\"\"\n    password: str\n\"\"\"the users password\"\"\"\n</code></pre>"},{"location":"auth/#osw.auth.CredentialManager.UserPwdCredential.password","title":"<code>password: str</code>  <code>instance-attribute</code>","text":"<p>the users password</p>"},{"location":"auth/#osw.auth.CredentialManager.UserPwdCredential.username","title":"<code>username: str</code>  <code>instance-attribute</code>","text":"<p>the user identifier</p>"},{"location":"auth/#osw.auth.CredentialManager.add_credential","title":"<code>add_credential(cred)</code>","text":"<p>adds a credential to the in memory store</p> <p>Parameters:</p> Name Type Description Default <code>cred</code> <code>BaseCredential</code> <p>the credential to add</p> required Source code in <code>src/osw/auth.py</code> <pre><code>def add_credential(self, cred: BaseCredential):\n\"\"\"adds a credential to the in memory store\n\n    Parameters\n    ----------\n    cred\n        the credential to add\n    \"\"\"\n    self._credentials.append(cred)\n</code></pre>"},{"location":"auth/#osw.auth.CredentialManager.get_credential","title":"<code>get_credential(config)</code>","text":"<p>Reads credentials from a yaml file or the in memory store</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>CredentialConfig</code> <p>see CredentialConfig</p> required <p>Returns:</p> Name Type Description <code>credential</code> <code>BaseCredential</code> <p>Credential, contain attributes 'username' and 'password' and the matching iri.</p> Source code in <code>src/osw/auth.py</code> <pre><code>def get_credential(self, config: CredentialConfig) -&gt; BaseCredential:\n\"\"\"Reads credentials from a yaml file or the in memory store\n\n    Parameters\n    ----------\n    config:\n        see CredentialConfig\n\n    Returns\n    -------\n    credential :\n        Credential, contain attributes 'username' and 'password' and the matching iri.\n    \"\"\"\n\n    _file_credentials: List[CredentialManager.BaseCredential] = []\n    if self.cred_filepath:\n        filepaths = self.cred_filepath\n        if type(filepaths) is not list:\n            filepaths = [filepaths]\n\n        for filepath in filepaths:\n            if filepath != \"\":\n                with open(filepath, \"r\") as stream:\n                    try:\n                        accounts = yaml.safe_load(stream)\n                        for iri in accounts.keys():\n                            if (\n                                \"username\" in accounts[iri]\n                                and \"password\" in accounts[iri]\n                            ):\n                                cred = CredentialManager.UserPwdCredential(\n                                    username=accounts[iri][\"username\"],\n                                    password=accounts[iri][\"password\"],\n                                    iri=iri,\n                                )\n                                _file_credentials.append(cred)\n                            if (\n                                \"consumer_token\" in accounts[iri]\n                                and \"consumer_secret\" in accounts[iri]\n                                and \"access_token\" in accounts[iri]\n                                and \"access_secret\" in accounts[iri]\n                            ):\n                                cred = CredentialManager.OAuth1Credential(\n                                    consumer_token=accounts[iri][\"consumer_token\"],\n                                    consumer_secret=accounts[iri][\n                                        \"consumer_secret\"\n                                    ],\n                                    access_token=accounts[iri][\"access_token\"],\n                                    access_secret=accounts[iri][\"access_secret\"],\n                                    iri=iri,\n                                )\n                                _file_credentials.append(cred)\n                    except yaml.YAMLError as exc:\n                        print(exc)\n\n    match_iri = \"\"\n    cred = None\n    creds = _file_credentials + self._credentials\n    for _cred in creds:\n        iri = _cred.iri\n        if config.iri in iri:\n            if match_iri == \"\" or len(match_iri) &gt; len(\n                iri\n            ):  # use the less specific match\n                match_iri = iri\n                cred = _cred\n\n    if cred is None:\n        if config.fallback is CredentialManager.CredentialFallback.ask:\n            print(\n                f\"No credentials for {config.iri} found. Please use the prompt to login\"\n            )\n            username = input(\"Enter username: \")\n            password = getpass.getpass(\"Enter password: \")\n            cred = CredentialManager.UserPwdCredential(\n                username=username, password=password, iri=config.iri\n            )\n    return cred\n</code></pre>"},{"location":"authors/","title":"Authors","text":"<p><code>{include} ../AUTHORS.md :relative-docs: docs/ :relative-images:</code></p>"},{"location":"changelog/","title":"Changelog","text":"<p><code>{include} ../CHANGELOG.md :relative-docs: docs/ :relative-images:</code></p>"},{"location":"contributing/","title":"Contributing","text":"<p><code>{include} ../CONTRIBUTING.md :relative-docs: docs/ :relative-images:</code></p>"},{"location":"controller/","title":"OpenSematicLab Controller","text":"<p>A controller extents a model class with functions</p>"},{"location":"controller/#entity","title":"Entity","text":"<p>             Bases: <code>Entity</code></p> Source code in <code>src/osw/controller/entity.py</code> <pre><code>class Entity(model.Entity):\n    def explain(self):\n        print(f\"Entity with label '{str(self.label[0].text)}'\")\n</code></pre>"},{"location":"controller/#databasecontroller","title":"DatabaseController","text":"<p>             Bases: <code>Database</code></p> <p>Provides a sqlalchemy engine for the specified database</p> Source code in <code>src/osw/controller/database.py</code> <pre><code>class DatabaseController(model.Database):\n\"\"\"\n    Provides a sqlalchemy engine for the specified database\n    \"\"\"\n\n    osw: Optional[OSW]\n\"\"\" an OSW instance to fetch related resources (host, server, etc.)\"\"\"\n    cm: Optional[CredentialManager]\n\"\"\" CredentialManager to login to the database\"\"\"\n    engine: Optional[Engine]\n\"\"\" the internal sqlalchemy engine \"\"\"\n\n    class Config:\n        arbitrary_types_allowed = True\n\n    class ConnectionString(OswBaseModel):\n\"\"\"the sqlalchemy database connection string\"\"\"\n\n        dialect: str\n\"\"\" sql subtype, e. g. postgres\"\"\"\n        username: str\n\"\"\" username for the login \"\"\"\n        password: str\n\"\"\" password for the login \"\"\"\n        host: str\n\"\"\" the database host (ip address or domain) \"\"\"\n        port: int\n\"\"\" the database port \"\"\"\n        database: str\n\"\"\" the database name / identifier \"\"\"\n        driver: Optional[str]\n\"\"\" specific driver, e. g. psycopg2 \"\"\"\n\n        def __str__(self):\n\"\"\"generates the string representation\n\n            Returns\n            -------\n                database connection string\n            \"\"\"\n            prefix = f\"{self.dialect}\"\n            if self.driver:\n                prefix += f\"+{self.driver}\"\n            url = URL.create(\n                prefix,\n                username=self.username,\n                password=self.password,\n                host=self.host,\n                port=self.port,\n                database=self.database,\n            )\n            return url.render_as_string(hide_password=False)\n\n    class ConnectionConfig(OswBaseModel):\n\"\"\"Database connection configuration\"\"\"\n\n        osw: OSW\n\"\"\" OSW instance to fetch related resources (host, server, etc.) \"\"\"\n        cm: Union[CredentialManager.BaseCredential, CredentialManager]\n\"\"\" CredentialManager or direct Credential to login to the database\"\"\"\n\n    def connect(self, config: ConnectionConfig):\n\"\"\"Initializes the connection to the database by creating a sqlalchemy engine\n\n        Parameters\n        ----------\n        config\n            see ConnectionConfig\n        \"\"\"\n        self.osw = config.osw\n        self.cm = config.cm\n\n        server_title = self.osw.site.semantic_search(\n            f\"[[-HasDbServer::Item:{self.osw.get_osw_id(self.uuid)}]]\"\n        )\n        server = self.osw.load_entity(server_title[0]).cast(model.DatabaseServer)\n\n        host_title = self.osw.site.semantic_search(\n            f\"[[-HasHost::Item:{self.osw.get_osw_id(server.uuid)}]]\"\n        )\n        host = self.osw.load_entity(host_title[0]).cast(model.Host)\n\n        dbtype_title = self.osw.site.semantic_search(\n            f\"[[-HasDbType::Item:{self.osw.get_osw_id(server.uuid)}]]\"\n        )\n        dbtype = self.osw.load_entity(dbtype_title[0]).cast(model.DatabaseType)\n\n        if isinstance(self.cm, CredentialManager.BaseCredential):\n            db_server_cred = self.cm\n        else:\n            db_server_cred = config.cm.get_credential(\n                CredentialManager.CredentialConfig(\n                    iri=f\"{host.network_domain[0]}:{server.network_port[0]}\",\n                    fallback=CredentialManager.CredentialFallback.ask,\n                )\n            )\n\n        cstr = DatabaseController.ConnectionString(\n            dialect=dbtype.connection_str_dialect,\n            driver=dbtype.connection_str_driver,\n            username=db_server_cred.username,\n            password=db_server_cred.password,\n            host=host.network_domain[0],\n            port=server.network_port[0],\n            database=self.name,\n        )\n\n        self.engine = create_engine(str(cstr))\n\n    def execute(self, sql: str):\n\"\"\"Executes a plain sql string\n\n        Parameters\n        ----------\n        sql\n            the sql string\n        \"\"\"\n        with self.engine.connect() as conn:\n            result_set = conn.execute(sql_text(sql))\n            for r in result_set:\n                print(r)\n</code></pre>"},{"location":"controller/#osw.controller.DatabaseController.cm","title":"<code>cm: Optional[CredentialManager]</code>  <code>instance-attribute</code>","text":"<p>CredentialManager to login to the database</p>"},{"location":"controller/#osw.controller.DatabaseController.engine","title":"<code>engine: Optional[Engine]</code>  <code>instance-attribute</code>","text":"<p>the internal sqlalchemy engine</p>"},{"location":"controller/#osw.controller.DatabaseController.osw","title":"<code>osw: Optional[OSW]</code>  <code>instance-attribute</code>","text":"<p>an OSW instance to fetch related resources (host, server, etc.)</p>"},{"location":"controller/#osw.controller.DatabaseController.ConnectionConfig","title":"<code>ConnectionConfig</code>","text":"<p>             Bases: <code>OswBaseModel</code></p> <p>Database connection configuration</p> Source code in <code>src/osw/controller/database.py</code> <pre><code>class ConnectionConfig(OswBaseModel):\n\"\"\"Database connection configuration\"\"\"\n\n    osw: OSW\n\"\"\" OSW instance to fetch related resources (host, server, etc.) \"\"\"\n    cm: Union[CredentialManager.BaseCredential, CredentialManager]\n\"\"\" CredentialManager or direct Credential to login to the database\"\"\"\n</code></pre>"},{"location":"controller/#osw.controller.DatabaseController.ConnectionConfig.cm","title":"<code>cm: Union[CredentialManager.BaseCredential, CredentialManager]</code>  <code>instance-attribute</code>","text":"<p>CredentialManager or direct Credential to login to the database</p>"},{"location":"controller/#osw.controller.DatabaseController.ConnectionConfig.osw","title":"<code>osw: OSW</code>  <code>instance-attribute</code>","text":"<p>OSW instance to fetch related resources (host, server, etc.)</p>"},{"location":"controller/#osw.controller.DatabaseController.ConnectionString","title":"<code>ConnectionString</code>","text":"<p>             Bases: <code>OswBaseModel</code></p> <p>the sqlalchemy database connection string</p> Source code in <code>src/osw/controller/database.py</code> <pre><code>class ConnectionString(OswBaseModel):\n\"\"\"the sqlalchemy database connection string\"\"\"\n\n    dialect: str\n\"\"\" sql subtype, e. g. postgres\"\"\"\n    username: str\n\"\"\" username for the login \"\"\"\n    password: str\n\"\"\" password for the login \"\"\"\n    host: str\n\"\"\" the database host (ip address or domain) \"\"\"\n    port: int\n\"\"\" the database port \"\"\"\n    database: str\n\"\"\" the database name / identifier \"\"\"\n    driver: Optional[str]\n\"\"\" specific driver, e. g. psycopg2 \"\"\"\n\n    def __str__(self):\n\"\"\"generates the string representation\n\n        Returns\n        -------\n            database connection string\n        \"\"\"\n        prefix = f\"{self.dialect}\"\n        if self.driver:\n            prefix += f\"+{self.driver}\"\n        url = URL.create(\n            prefix,\n            username=self.username,\n            password=self.password,\n            host=self.host,\n            port=self.port,\n            database=self.database,\n        )\n        return url.render_as_string(hide_password=False)\n</code></pre>"},{"location":"controller/#osw.controller.DatabaseController.ConnectionString.database","title":"<code>database: str</code>  <code>instance-attribute</code>","text":"<p>the database name / identifier</p>"},{"location":"controller/#osw.controller.DatabaseController.ConnectionString.dialect","title":"<code>dialect: str</code>  <code>instance-attribute</code>","text":"<p>sql subtype, e. g. postgres</p>"},{"location":"controller/#osw.controller.DatabaseController.ConnectionString.driver","title":"<code>driver: Optional[str]</code>  <code>instance-attribute</code>","text":"<p>specific driver, e. g. psycopg2</p>"},{"location":"controller/#osw.controller.DatabaseController.ConnectionString.host","title":"<code>host: str</code>  <code>instance-attribute</code>","text":"<p>the database host (ip address or domain)</p>"},{"location":"controller/#osw.controller.DatabaseController.ConnectionString.password","title":"<code>password: str</code>  <code>instance-attribute</code>","text":"<p>password for the login</p>"},{"location":"controller/#osw.controller.DatabaseController.ConnectionString.port","title":"<code>port: int</code>  <code>instance-attribute</code>","text":"<p>the database port</p>"},{"location":"controller/#osw.controller.DatabaseController.ConnectionString.username","title":"<code>username: str</code>  <code>instance-attribute</code>","text":"<p>username for the login</p>"},{"location":"controller/#osw.controller.DatabaseController.ConnectionString.__str__","title":"<code>__str__()</code>","text":"<p>generates the string representation</p> <p>Returns:</p> Type Description <code>    database connection string</code> Source code in <code>src/osw/controller/database.py</code> <pre><code>def __str__(self):\n\"\"\"generates the string representation\n\n    Returns\n    -------\n        database connection string\n    \"\"\"\n    prefix = f\"{self.dialect}\"\n    if self.driver:\n        prefix += f\"+{self.driver}\"\n    url = URL.create(\n        prefix,\n        username=self.username,\n        password=self.password,\n        host=self.host,\n        port=self.port,\n        database=self.database,\n    )\n    return url.render_as_string(hide_password=False)\n</code></pre>"},{"location":"controller/#osw.controller.DatabaseController.connect","title":"<code>connect(config)</code>","text":"<p>Initializes the connection to the database by creating a sqlalchemy engine</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ConnectionConfig</code> <p>see ConnectionConfig</p> required Source code in <code>src/osw/controller/database.py</code> <pre><code>def connect(self, config: ConnectionConfig):\n\"\"\"Initializes the connection to the database by creating a sqlalchemy engine\n\n    Parameters\n    ----------\n    config\n        see ConnectionConfig\n    \"\"\"\n    self.osw = config.osw\n    self.cm = config.cm\n\n    server_title = self.osw.site.semantic_search(\n        f\"[[-HasDbServer::Item:{self.osw.get_osw_id(self.uuid)}]]\"\n    )\n    server = self.osw.load_entity(server_title[0]).cast(model.DatabaseServer)\n\n    host_title = self.osw.site.semantic_search(\n        f\"[[-HasHost::Item:{self.osw.get_osw_id(server.uuid)}]]\"\n    )\n    host = self.osw.load_entity(host_title[0]).cast(model.Host)\n\n    dbtype_title = self.osw.site.semantic_search(\n        f\"[[-HasDbType::Item:{self.osw.get_osw_id(server.uuid)}]]\"\n    )\n    dbtype = self.osw.load_entity(dbtype_title[0]).cast(model.DatabaseType)\n\n    if isinstance(self.cm, CredentialManager.BaseCredential):\n        db_server_cred = self.cm\n    else:\n        db_server_cred = config.cm.get_credential(\n            CredentialManager.CredentialConfig(\n                iri=f\"{host.network_domain[0]}:{server.network_port[0]}\",\n                fallback=CredentialManager.CredentialFallback.ask,\n            )\n        )\n\n    cstr = DatabaseController.ConnectionString(\n        dialect=dbtype.connection_str_dialect,\n        driver=dbtype.connection_str_driver,\n        username=db_server_cred.username,\n        password=db_server_cred.password,\n        host=host.network_domain[0],\n        port=server.network_port[0],\n        database=self.name,\n    )\n\n    self.engine = create_engine(str(cstr))\n</code></pre>"},{"location":"controller/#osw.controller.DatabaseController.execute","title":"<code>execute(sql)</code>","text":"<p>Executes a plain sql string</p> <p>Parameters:</p> Name Type Description Default <code>sql</code> <code>str</code> <p>the sql string</p> required Source code in <code>src/osw/controller/database.py</code> <pre><code>def execute(self, sql: str):\n\"\"\"Executes a plain sql string\n\n    Parameters\n    ----------\n    sql\n        the sql string\n    \"\"\"\n    with self.engine.connect() as conn:\n        result_set = conn.execute(sql_text(sql))\n        for r in result_set:\n            print(r)\n</code></pre>"},{"location":"dev/","title":"Setup","text":"<ol> <li>create a virtual environment</li> </ol> <pre><code>python -m venv .venv\n</code></pre> <ol> <li>install requirements + extras</li> </ol> <pre><code>pip install -e .[dev,testing]\n</code></pre>"},{"location":"dev/#testing","title":"Testing","text":"<ol> <li> <p>Create new test (file name test_*.py) under /tests</p> </li> <li> <p>Run pytest in the project root dir</p> </li> </ol> <pre><code>tox -e test\n</code></pre> <ol> <li>To run integration test with credentials, run</li> </ol> <pre><code>tox -e test -- --wiki_domain \"&lt;domain&gt;\" --wiki_username \"&lt;login&gt;\" --wiki_password \"&lt;password&gt;\"\n</code></pre>"},{"location":"license/","title":"License","text":"<p><code>{literalinclude} ../LICENSE.txt :language: text</code></p>"},{"location":"model/","title":"Model","text":"<p>OpenSematicLab Model</p>"},{"location":"model/#entity","title":"Entity","text":"<p>             Bases: <code>OswBaseModel</code></p> Source code in <code>src/osw/model/entity.py</code> <pre><code>class Entity(OswBaseModel):\n    uuid: UUID = Field(default_factory=uuid4, title=\"UUID\")\n    name: Optional[str] = Field(None, title=\"Name\")\n\"\"\"\n    Technical / Machine compatible name\n    \"\"\"\n    label: List[Label] = Field(..., min_items=1, title=\"Labels\")\n\"\"\"\n    Human readable names. You have to assign at least one.\n    \"\"\"\n    short_name: Optional[List[Label]] = Field(None, title=\"Short name\")\n\"\"\"\n    Abbreviation, Acronym, etc.\n    \"\"\"\n    query_label: Optional[str] = Field(None, title=\"Label\")\n    description: Optional[List[Description]] = Field(None, title=\"Description\")\n    image: Optional[str] = Field(None, title=\"Image\")\n    based_on: Optional[List[str]] = Field(None, title=\"Based on\")\n\"\"\"\n    Other entities on which this one is based, e.g. when it is created by copying\n    \"\"\"\n    statements: Optional[\n        List[Union[ObjectStatement, DataStatement, QuantityStatement]]\n    ] = Field(None, title=\"Statements\")\n    attachments: Optional[List[str]] = Field(None, title=\"File attachments\")\n</code></pre>"},{"location":"model/#osw.model.entity.Entity.based_on","title":"<code>based_on: Optional[List[str]] = Field(None, title='Based on')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Other entities on which this one is based, e.g. when it is created by copying</p>"},{"location":"model/#osw.model.entity.Entity.label","title":"<code>label: List[Label] = Field(..., min_items=1, title='Labels')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Human readable names. You have to assign at least one.</p>"},{"location":"model/#osw.model.entity.Entity.name","title":"<code>name: Optional[str] = Field(None, title='Name')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Technical / Machine compatible name</p>"},{"location":"model/#osw.model.entity.Entity.short_name","title":"<code>short_name: Optional[List[Label]] = Field(None, title='Short name')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Abbreviation, Acronym, etc.</p>"},{"location":"osw/","title":"Osw","text":"<p>OpenSematicWorld Class</p>"},{"location":"osw/#osw","title":"OSW","text":"<p>             Bases: <code>BaseModel</code></p> <p>Bundles core functionalities of OpenSemanticWorld (OSW)</p> Source code in <code>src/osw/core.py</code> <pre><code>class OSW(BaseModel):\n\"\"\"Bundles core functionalities of OpenSemanticWorld (OSW)\"\"\"\n\n    uuid: str = \"2ea5b605-c91f-4e5a-9559-3dff79fdd4a5\"\n    _protected_keywords = (\n        \"_osl_template\",\n        \"_osl_footer\",\n    )  # private properties included in model export\n\n    class Config:\n        arbitrary_types_allowed = True  # neccessary to allow e.g. np.array as type\n\n    site: WtSite\n\n    @staticmethod\n    def get_osw_id(uuid: uuid) -&gt; str:\n\"\"\"Generates a OSW-ID based on the given uuid by prefixing \"OSW\" and removing\n        all '-' from the uuid-string\n\n        Parameters\n        ----------\n        uuid\n            uuid object, e. g. UUID(\"2ea5b605-c91f-4e5a-9559-3dff79fdd4a5\")\n\n        Returns\n        -------\n            OSW-ID string, e. g. OSW2ea5b605c91f4e5a95593dff79fdd4a5\n        \"\"\"\n        return \"OSW\" + str(uuid).replace(\"-\", \"\")\n\n    @staticmethod\n    def get_uuid(osw_id) -&gt; uuid:\n\"\"\"Returns the uuid for a given OSW-ID\n\n        Parameters\n        ----------\n        osw_id\n            OSW-ID string, e. g. OSW2ea5b605c91f4e5a95593dff79fdd4a5\n\n        Returns\n        -------\n            uuid object, e. g. UUID(\"2ea5b605-c91f-4e5a-9559-3dff79fdd4a5\")\n        \"\"\"\n        return UUID(osw_id.replace(\"OSW\", \"\"))\n\n    class SchemaRegistration(BaseModel):\n\"\"\"\n        dataclass param of register_schema()\n\n        Attributes\n        ----------\n        model_cls:\n            the model class\n        schema_name:\n            the name of the schema\n        schema_bases:\n            list of base schemas (referenced by allOf)\n        \"\"\"\n\n        class Config:\n            arbitrary_types_allowed = True  # allow any class as type\n\n        model_cls: ModelMetaclass\n        schema_uuid = str  # Optional[str] = model_cls.__uuid__\n        schema_name: str  # Optional[str] = model_cls.__name__\n        schema_bases: List[str] = [\"Category:Item\"]\n\n    def register_schema(self, schema_registration: SchemaRegistration):\n\"\"\"Registers a new or updated schema in OSW by creating the corresponding\n        category page.\n\n        Parameters\n        ----------\n        schema_registration\n            see SchemaRegistration\n        \"\"\"\n        entity = schema_registration.model_cls\n\n        jsondata = {}\n        jsondata[\"uuid\"] = schema_registration.schema_uuid\n        jsondata[\"label\"] = {\"text\": schema_registration.schema_name, \"lang\": \"en\"}\n        jsondata[\"subclass_of\"] = schema_registration.schema_bases\n\n        if issubclass(entity, BaseModel):\n            entity_title = \"Category:\" + OSW.get_osw_id(schema_registration.schema_uuid)\n            page = self.site.get_page(WtSite.GetPageParam(titles=[entity_title])).pages[\n                0\n            ]\n\n            page.set_slot_content(\"jsondata\", jsondata)\n\n            # entity = ModelMetaclass(entity.__name__, (BaseModel,), dict(entity.__dict__)) #strips base classes but fiels are already importet\n            schema = json.loads(\n                entity.schema_json(indent=4).replace(\"$ref\", \"dollarref\")\n            )\n\n            jsonpath_expr = parse(\"$..allOf\")\n            # replace local definitions (#/definitions/...) with embedded definitions to prevent resolve errors in json-editor\n            for match in jsonpath_expr.find(schema):\n                result_array = []\n                for subschema in match.value:\n                    # pprint(subschema)\n                    value = subschema[\"dollarref\"]\n                    if value.startswith(\"#\"):\n                        definition_jsonpath_expr = parse(\n                            value.replace(\"#\", \"$\").replace(\"/\", \".\")\n                        )\n                        for def_match in definition_jsonpath_expr.find(schema):\n                            # pprint(def_match.value)\n                            result_array.append(def_match.value)\n                    else:\n                        result_array.append(subschema)\n                match.full_path.update_or_create(schema, result_array)\n            if \"definitions\" in schema:\n                del schema[\"definitions\"]\n\n            if \"allOf\" not in schema:\n                schema[\"allOf\"] = []\n            for base in schema_registration.schema_bases:\n                schema[\"allOf\"].append(\n                    {\"$ref\": f\"/wiki/{base}?action=raw&amp;slot=jsonschema\"}\n                )\n\n            page.set_slot_content(\"jsonschema\", schema)\n        else:\n            print(\"Error: Unsupported entity type\")\n            return\n\n        page.edit()\n        print(\"Entity stored at \" + page.get_url())\n\n    class SchemaUnregistration(BaseModel):\n\"\"\"\n        dataclass param of register_schema()\n\n        Attributes\n        ----------\n        model_cls:\n            the model class\n        schema_name:\n            the name of the schema\n        schema_bases:\n            list of base schemas (referenced by allOf)\n        \"\"\"\n\n        class Config:\n            arbitrary_types_allowed = True  # allow any class as type\n\n        model_cls: Optional[ModelMetaclass]\n        model_uuid: Optional[str]\n        comment: Optional[str]\n\n    def unregister_schema(self, schema_unregistration: SchemaUnregistration):\n\"\"\"deletes the corresponding category page\n\n        Parameters\n        ----------\n        schema_unregistration\n            see SchemaUnregistration\n        \"\"\"\n        uuid = \"\"\n        if schema_unregistration.model_uuid:\n            uuid = schema_unregistration.model_uuid\n        elif (\n            not uuid\n            and schema_unregistration.model_cls\n            and issubclass(schema_unregistration.model_cls, BaseModel)\n        ):\n            uuid = schema_unregistration.model_cls.__uuid__\n        else:\n            print(\"Error: Neither model nor model id provided\")\n\n        entity_title = \"Category:\" + OSW.get_osw_id(uuid)\n        page = self.site.get_page(WtSite.GetPageParam(titles=[entity_title])).pages[0]\n        page.delete(schema_unregistration.comment)\n\n    class FetchSchemaMode(Enum):\n\"\"\"Modes of the FetchSchemaParam class\n\n        Attributes\n        ----------\n        append:\n            append to the current model\n        replace:\n            replace the current model\n        \"\"\"\n\n        append = \"append\"  # append to the current model\n        replace = \"replace\"  # replace the current model\n\n    class FetchSchemaParam(BaseModel):\n\"\"\"_summary_\n\n        Attributes\n        ----------\n        schema_title:\n            the title (wiki page name) of the schema (default: Category:Item)\n        root:\n            marks the root iteration for a recursive fetch (internal param,\n            default: True)\n        mode:\n            append or replace (default) current schema, see FetchSchemaMode\n        \"\"\"\n\n        schema_title: Optional[str] = \"Category:Item\"\n        root: Optional[bool] = True\n        mode: Optional[\n            str\n        ] = \"replace\"  # type 'FetchSchemaMode' requires: 'from __future__ import annotations'\n\n    def fetch_schema(self, fetchSchemaParam: FetchSchemaParam = None) -&gt; None:\n\"\"\"Loads the given schema from the OSW instance and autogenerates python\n        datasclasses within osw.model.entity from it\n\n        Parameters\n        ----------\n        fetchSchemaParam\n            See FetchSchemaParam, by default None\n        \"\"\"\n        site_cache_state = self.site.get_cache_enabled()\n        self.site.enable_cache()\n        if fetchSchemaParam is None:\n            fetchSchemaParam = OSW.FetchSchemaParam()\n        schema_title = fetchSchemaParam.schema_title\n        root = fetchSchemaParam.root\n        schema_name = schema_title.split(\":\")[-1]\n        page = self.site.get_page(WtSite.GetPageParam(titles=[schema_title])).pages[0]\n        if not page.exists:\n            print(f\"Error: Page {schema_title} does not exist\")\n            return\n        if schema_title.startswith(\"Category:\"):\n            schema_str = json.dumps(page.get_slot_content(\"jsonschema\"))\n        else:\n            schema_str = page.get_content()\n        schema = json.loads(\n            schema_str.replace(\"$ref\", \"dollarref\")\n        )  # '$' is a special char for root object in jsonpath\n        print(f\"Fetch {schema_title}\")\n\n        jsonpath_expr = parse(\"$..dollarref\")\n        for match in jsonpath_expr.find(schema):\n            # value = \"https://\" + self.site._site.host + match.value\n            if match.value.startswith(\"#\"):\n                continue  # skip self references\n            ref_schema_title = match.value.replace(\"/wiki/\", \"\").split(\"?\")[0]\n            ref_schema_name = ref_schema_title.split(\":\")[-1] + \".json\"\n            value = \"\"\n            for i in range(0, schema_name.count(\"/\")):\n                value += \"../\"  # created relative path to top-level schema dir\n            value += ref_schema_name  # create a reference to a local file\n            match.full_path.update_or_create(schema, value)\n            # print(f\"replace {match.value} with {value}\")\n            if (\n                ref_schema_title != schema_title\n            ):  # prevent recursion in case of self references\n                self.fetch_schema(\n                    OSW.FetchSchemaParam(schema_title=ref_schema_title, root=False)\n                )  # resolve references recursive\n\n        model_dir_path = os.path.join(\n            os.path.dirname(os.path.abspath(__file__)), \"model\"\n        )  # src/model\n        schema_path = os.path.join(model_dir_path, schema_name + \".json\")\n        os.makedirs(os.path.dirname(schema_path), exist_ok=True)\n        with open(schema_path, \"w\", encoding=\"utf-8\") as f:\n            schema_str = json.dumps(schema, ensure_ascii=False, indent=4).replace(\n                \"dollarref\", \"$ref\"\n            )\n            # print(schema_str)\n            f.write(schema_str)\n\n        # result_model_path = schema_path.replace(\".json\", \".py\")\n        result_model_path = os.path.join(model_dir_path, \"entity.py\")\n        temp_model_path = os.path.join(model_dir_path, \"temp.py\")\n        if root:\n            exec_name = \"datamodel-codegen\"\n            if platform.system() == \"Windows\":\n                exec_name += \".exe\"\n            exec_path = os.path.join(\n                os.path.dirname(os.path.abspath(sys.executable)), exec_name\n            )\n            if not os.path.isfile(exec_path):\n                exec_path = os.path.join(\n                    os.path.dirname(os.path.abspath(sys.executable)),\n                    \"Scripts\",\n                    exec_name,\n                )\n            if not os.path.isfile(exec_path):\n                print(\"Error: datamodel-codegen not found\")\n                return\n            os.system(\n                f\"{exec_path}  \\\n                --input {schema_path} \\\n                --input-file-type jsonschema \\\n                --output {temp_model_path} \\\n                --base-class osw.model.static.OswBaseModel \\\n                --use-default \\\n                --enum-field-as-literal all \\\n                --use-title-as-name \\\n                --use-schema-description \\\n                --use-field-description \\\n                --encoding utf-8 \\\n                --use-double-quotes \\\n                --collapse-root-models \\\n                --reuse-model \\\n            \"\n            )\n            # see https://koxudaxi.github.io/datamodel-code-generator/\n            # --base-class OswBaseModel: use a custom base class\n            # --custom-template-dir src/model/template_data/\n            # --extra-template-data src/model/template_data/extra.json\n            # --use-default: Use default value even if a field is required\n            # --enum-field-as-literal all: prevent 'value is not a valid enumeration member' errors after schema reloading\n            # --use-schema-description: Use schema description to populate class docstring\n            # --use-field-description: Use schema description to populate field docstring\n            # --use-title-as-name: use titles as class names of models, e. g. for the footer templates\n            # --collapse-root-models: Models generated with a root-type field will be merged\n            # into the models using that root-type model, e. g. for Entity.statements\n            # --reuse-model: Re-use models on the field when a module has the model with the same content\n\n            # this is dirty, but required for autocompletion: https://stackoverflow.com/questions/62884543/pydantic-autocompletion-in-vs-code\n            # idealy solved by custom templates in the future: https://github.com/koxudaxi/datamodel-code-generator/issues/860\n\n            content = \"\"\n            with open(temp_model_path, \"r\", encoding=\"utf-8\") as f:\n                content = f.read()\n            os.remove(temp_model_path)\n\n            # Statement and its subclasses are a complex case that needs manual fixing\n\n            # datamodel-codegen &lt;= 0.15.0\n            # make statement classes subclasses of Statement\n            content = re.sub(\n                r\"ObjectStatement\\(OswBaseModel\\)\",\n                r\"ObjectStatement(Statement)\",\n                content,\n            )\n            content = re.sub(\n                r\"DataStatement\\(OswBaseModel\\)\", r\"DataStatement(Statement)\", content\n            )\n            content = re.sub(\n                r\"QuantityStatement\\(OswBaseModel\\)\",\n                r\"QuantityStatement(Statement)\",\n                content,\n            )\n            # make statement lists union of all statement types\n            content = re.sub(\n                r\"List\\[Statement\\]\",\n                r\"List[Union[ObjectStatement, DataStatement, QuantityStatement]]\",\n                content,\n            )\n            # remove Statement class\n            content = re.sub(\n                r\"(class\\s*\"\n                + \"Statement\"\n                + r\"\\s*\\(\\s*\\S*\\s*\\)\\s*:.*\\n[\\s\\S]*?(?:[^\\S\\n]*\\n){3,})\",\n                \"\",\n                content,\n                count=1,\n            )\n            # rename Statement1 to Statement\n            content = re.sub(r\"Statement1\", r\"Statement\", content)\n            # add forward refs\n            content = re.sub(\n                r\"Statement.update_forward_refs\\(\\)\",\n                r\"Statement.update_forward_refs()\\nObjectStatement.update_forward_refs()\\nDataStatement.update_forward_refs()\\nQuantityStatement.update_forward_refs()\",\n                content,\n            )\n            pattern = re.compile(\n                r\"(class\\s*\"\n                + \"Statement\"\n                + r\"\\s*\\(\\s*\\S*\\s*\\)\\s*:.*\\n[\\s\\S]*?(?:[^\\S\\n]*\\n){3,})\"\n            )  # match Statement class definition\n            for cls in re.findall(pattern, content):\n                # remove class\n                content = re.sub(\n                    r\"(class\\s*\"\n                    + \"Statement\"\n                    + r\"\\s*\\(\\s*\\S*\\s*\\)\\s*:.*\\n[\\s\\S]*?(?:[^\\S\\n]*\\n){3,})\",\n                    \"\",\n                    content,\n                    count=1,\n                )\n                content = re.sub(\n                    r\"(class\\s*\\S*\\s*\\(\\s*Statement\\s*\\)\\s*:.*\\n)\",\n                    cls + r\"\\1\",\n                    content,\n                    1,\n                )  # insert class definition before first reference\n                break\n\n            # datamodel-codegen &gt; 0.15.0\n            # Rename statement classes (ObjectStatement, DataStatement, QuantityStatement)\n            # content = re.sub(r\"ObjectStatement\", r\"_ObjectStatement\", content)\n            # content = re.sub(r\"DataStatement\", r\"_DataStatement\", content)\n            # content = re.sub(r\"QuantityStatement\", r\"_QuantityStatement\", content)\n            # class Statement1(_ObjectStatement):\n            # content = re.sub(r\"class\\s*\\S*(\\s*\\(\\s*_ObjectStatement\\s*\\))\", r\"class ObjectStatement\\1\", content)\n            # content = re.sub(r\"class\\s*\\S*(\\s*\\(\\s*_DataStatement\\s*\\))\", r\"class DataStatement\\1\", content)\n            # content = re.sub(r\"class\\s*\\S*(\\s*\\(\\s*_QuantityStatement\\s*\\))\", r\"class QuantityStatement\\1\", content)\n            # Union[Statement1, Statement2, Statement3] and Statement&lt;x&gt;.update_forward_refs()\n            # content = re.sub(r\"Statement1\", r\"ObjectStatement\", content)\n            # content = re.sub(r\"Statement2\", r\"DataStatement\", content)\n            # content = re.sub(r\"Statement3\", r\"QuantityStatement\", content)\n\n            if fetchSchemaParam.mode == \"replace\":\n                header = (\n                    \"from uuid import uuid4\\n\"\n                    \"from typing import Type, TypeVar\\n\"\n                    \"from osw.model.static import OswBaseModel, Ontology\\n\"\n                    \"\\n\"\n                )\n\n                content = re.sub(\n                    r\"(class\\s*\\S*\\s*\\(\\s*OswBaseModel\\s*\\)\\s*:.*\\n)\",\n                    header + r\"\\n\\n\\n\\1\",\n                    content,\n                    1,\n                )  # add header before first class declaration\n\n                content = re.sub(\n                    r\"(UUID = Field\\(...)\",\n                    r\"UUID = Field(default_factory=uuid4\",\n                    content,\n                )  # enable default value for uuid\n                with open(result_model_path, \"w\", encoding=\"utf-8\") as f:\n                    f.write(content)\n\n            if fetchSchemaParam.mode == \"append\":\n                org_content = \"\"\n                with open(result_model_path, \"r\", encoding=\"utf-8\") as f:\n                    org_content = f.read()\n\n                pattern = re.compile(\n                    r\"class\\s*([\\S]*)\\s*\\(\\s*\\S*\\s*\\)\\s*:.*\\n\"\n                )  # match class definition [\\s\\S]*(?:[^\\S\\n]*\\n){2,}\n                for cls in re.findall(pattern, org_content):\n                    print(cls)\n                    content = re.sub(\n                        r\"(class\\s*\"\n                        + cls\n                        + r\"\\s*\\(\\s*\\S*\\s*\\)\\s*:.*\\n[\\s\\S]*?(?:[^\\S\\n]*\\n){3,})\",\n                        \"\",\n                        content,\n                        count=1,\n                    )  # replace duplicated classes\n\n                content = re.sub(\n                    r\"(from __future__ import annotations)\", \"\", content, 1\n                )  # remove import statement\n                # print(content)\n                with open(result_model_path, \"a\", encoding=\"utf-8\") as f:\n                    f.write(content)\n\n            importlib.reload(model)  # reload the updated module\n            if not site_cache_state:\n                self.site.disable_cache()  # restore original state\n\n    def load_entity(self, entity_title) -&gt; model.Entity:\n\"\"\"Loads the entity with the given wiki page name from the OSW instance.\n        Creates an instance of the class specified by the \"type\" attribute, default\n        model.Entity. An instance of model.Entity can be cast to any subclass with\n        .cast(model.&lt;class&gt;) .\n\n        Parameters\n        ----------\n        entity_title\n            the wiki page name\n\n        Returns\n        -------\n            the dataclass instance\n        \"\"\"\n        entity = None\n        schemas = []\n        page = self.site.get_page(WtSite.GetPageParam(titles=[entity_title])).pages[0]\n        jsondata = page.get_slot_content(\"jsondata\")\n        if jsondata:\n            for category in jsondata[\"type\"]:\n                schema = (\n                    self.site.get_page(WtSite.GetPageParam(titles=[category]))\n                    .pages[0]\n                    .get_slot_content(\"jsonschema\")\n                )\n                schemas.append(schema)\n\n        if len(schemas) == 0:\n            print(\"Error: no schema defined\")\n\n        elif len(schemas) == 1:\n            cls = schemas[0][\"title\"]\n            entity = eval(f\"model.{cls}(**jsondata)\")\n\n        else:\n            bases = []\n            for schema in schemas:\n                bases.append(eval(\"model.\" + schema[\"title\"]))\n            cls = create_model(\"Test\", __base__=tuple(bases))\n            entity = cls(**jsondata)\n            entity.meta = model.Meta(\n                wiki_page=model.WikiPage(\n                    namespace=namespace_from_full_title(entity_title),\n                    title=title_from_full_title(entity_title),\n                )\n            )\n\n        return entity\n\n    class StoreEntityParam(model.OswBaseModel):\n        entities: Union[OswBaseModel, List[OswBaseModel]]\n        namespace: Optional[str]\n        parallel: Optional[bool] = False\n        meta_category_title: Optional[str] = \"Category:Category\"\n        debug: Optional[bool] = False\n\n    def store_entity(\n        self, param: Union[StoreEntityParam, OswBaseModel, List[OswBaseModel]]\n    ) -&gt; None:\n\"\"\"stores the given dataclass instance as OSW page by calling BaseModel.json()\n\n        Parameters\n        ----------\n        param:\n            StoreEntityParam, the dataclass instance or a list of instances\n        \"\"\"\n        if isinstance(param, model.Entity):\n            param = OSW.StoreEntityParam(entities=[param])\n        if isinstance(param, list):\n            param = OSW.StoreEntityParam(entities=param)\n        if not isinstance(param.entities, list):\n            param.entities = [param.entities]\n\n        max_index = len(param.entities)\n        if max_index &gt;= 5:\n            param.parallel = True\n\n        meta_category = self.site.get_page(\n            WtSite.GetPageParam(titles=[param.meta_category_title])\n        ).pages[0]\n\n        def store_entity_(\n            entity: model.Entity, namespace_: str = None, index: int = None\n        ) -&gt; None:\n            title_ = get_title(entity)\n            if namespace_ is None:\n                namespace_ = get_namespace(entity)\n            if namespace_ is None or title_ is None:\n                print(\"Error: Unsupported entity type\")\n                return\n            entity_title = namespace_ + \":\" + title_\n            page = self.site.get_page(WtSite.GetPageParam(titles=[entity_title])).pages[\n                0\n            ]\n\n            jsondata = json.loads(\n                entity.json(exclude_none=True)\n            )  # use pydantic serialization, skip none values\n            page.set_slot_content(\"jsondata\", jsondata)\n            page.set_slot_content(\n                \"header\", \"{{#invoke:Entity|header}}\"\n            )  # required for json parsing and header rendering\n            page.set_slot_content(\n                \"footer\", \"{{#invoke:Entity|footer}}\"\n            )  # required for footer rendering\n            if namespace_ == \"Category\":\n                template = meta_category.get_slot_content(\"schema_template\")\n                if template:\n                    schema = json.loads(\n                        eval_handlebars_template(\n                            template, jsondata, {\"_page_title\": entity_title}\n                        )\n                    )\n                    page.set_slot_content(\"jsonschema\", schema)\n            page.edit()\n            if index is None:\n                print(f\"Entity stored at {page.get_url()}.\")\n            else:\n                print(\n                    f\"({index + 1}/{max_index}) Entity stored at \" f\"{page.get_url()}.\"\n                )\n\n        if param.parallel:\n            _ = parallelize(\n                store_entity_,\n                param.entities,\n                flush_at_end=param.debug,\n                namespace_=param.namespace,\n            )\n        else:\n            _ = [\n                store_entity_(e, param.namespace, i)\n                for i, e in enumerate(param.entities)\n            ]\n\n    class DeleteEntityParam(model.OswBaseModel):\n        entities: List[model.OswBaseModel]\n        comment: Optional[str] = None\n        parallel: Optional[bool] = False\n        debug: Optional[bool] = False\n\n    def delete_entity(\n        self, entity: Union[model.OswBaseModel, DeleteEntityParam], comment: str = None\n    ):\n\"\"\"Deletes the given entity/entities from the OSW instance.\"\"\"\n        if not isinstance(entity, OSW.DeleteEntityParam):\n            if isinstance(entity, list):\n                entity = OSW.DeleteEntityParam(entities=entity)\n            else:\n                entity = OSW.DeleteEntityParam(entities=[entity])\n        if comment is not None:\n            entity.comment = comment\n        if len(entity.entities) &gt;= 5:\n            entity.parallel = True\n\n        def delete_entity_(entity, comment_: str = None):\n\"\"\"Deletes the given entity from the OSW instance.\n\n            Parameters\n            ----------\n            entity:\n                The dataclass instance to delete\n            comment_:\n                Command for the change log, by default None\n            \"\"\"\n            title_ = None\n            namespace_ = None\n            if hasattr(entity, \"meta\") and entity.meta and entity.meta.wiki_page:\n                if entity.meta.wiki_page.title:\n                    title_ = entity.meta.wiki_page.title\n                if entity.meta.wiki_page.namespace:\n                    namespace_ = entity.meta.wiki_page.namespace\n            if namespace_ is None:\n                namespace_ = get_namespace(entity)\n            if title_ is None:\n                title_ = OSW.get_osw_id(entity.uuid)\n            if namespace_ is None or title_ is None:\n                print(\"Error: Unsupported entity type\")\n                return\n            entity_title = namespace_ + \":\" + title_\n            page = self.site.get_page(WtSite.GetPageParam(titles=[entity_title])).pages[\n                0\n            ]\n\n            if page.exists:\n                page.delete(comment_)\n                print(\"Entity deleted: \" + page.get_url())\n            else:\n                print(f\"Entity '{entity_title}' does not exist!\")\n\n        if entity.parallel:\n            _ = parallelize(\n                delete_entity_,\n                entity.entities,\n                flush_at_end=entity.debug,\n                comment_=entity.comment,\n            )\n        else:\n            _ = [delete_entity_(e, entity.comment) for e in entity.entities]\n\n    class QueryInstancesParam(model.OswBaseModel):\n        categories: List[Union[str, OswBaseModel]]\n        parallel: Optional[bool] = False\n        debug: Optional[bool] = False\n        limit: Optional[int] = 1000\n\n    def query_instances(\n        self, category: Union[str, OswBaseModel, OSW.QueryInstancesParam]\n    ) -&gt; List[str]:\n        def get_page_title(category_: Union[str, OswBaseModel]) -&gt; str:\n            error_msg = (\n                \"Category must be a string, a dataclass instance with \"\n                \"a 'type' attribute or osw.wiki_tools.SearchParam.\"\n            )\n            if isinstance(category_, str):\n                return category_.split(\":\")[-1]  # page title w/o namespace\n            elif isinstance(category_, model.OswBaseModel):\n                type_ = getattr(category_, \"type\", None)\n                if type_:\n                    full_page_title = type_[0]\n                    return full_page_title.split(\":\")[-1]  # page title w/o namespace\n                else:\n                    raise TypeError(error_msg)\n            else:\n                raise TypeError(error_msg)\n\n        if isinstance(category, OSW.QueryInstancesParam):\n            page_titles = [get_page_title(cat) for cat in category.categories]\n        else:\n            page_titles = [get_page_title(category)]\n            category = OSW.QueryInstancesParam(category=page_titles)\n\n        search_param = SearchParam(\n            query=[f\"[[HasType::Category:{page_title}]]\" for page_title in page_titles],\n            **category.dict(exclude={\"categories\"}),\n        )\n        full_page_titles = self.site.semantic_search(search_param)\n        return full_page_titles\n</code></pre>"},{"location":"osw/#osw.core.OSW.FetchSchemaMode","title":"<code>FetchSchemaMode</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Modes of the FetchSchemaParam class</p> <p>Attributes:</p> Name Type Description <code>append</code> <p>append to the current model</p> <code>replace</code> <p>replace the current model</p> Source code in <code>src/osw/core.py</code> <pre><code>class FetchSchemaMode(Enum):\n\"\"\"Modes of the FetchSchemaParam class\n\n    Attributes\n    ----------\n    append:\n        append to the current model\n    replace:\n        replace the current model\n    \"\"\"\n\n    append = \"append\"  # append to the current model\n    replace = \"replace\"  # replace the current model\n</code></pre>"},{"location":"osw/#osw.core.OSW.FetchSchemaParam","title":"<code>FetchSchemaParam</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>summary</p> <p>Attributes:</p> Name Type Description <code>schema_title</code> <code>Optional[str]</code> <p>the title (wiki page name) of the schema (default: Category:Item)</p> <code>root</code> <code>Optional[bool]</code> <p>marks the root iteration for a recursive fetch (internal param, default: True)</p> <code>mode</code> <code>Optional[str]</code> <p>append or replace (default) current schema, see FetchSchemaMode</p> Source code in <code>src/osw/core.py</code> <pre><code>class FetchSchemaParam(BaseModel):\n\"\"\"_summary_\n\n    Attributes\n    ----------\n    schema_title:\n        the title (wiki page name) of the schema (default: Category:Item)\n    root:\n        marks the root iteration for a recursive fetch (internal param,\n        default: True)\n    mode:\n        append or replace (default) current schema, see FetchSchemaMode\n    \"\"\"\n\n    schema_title: Optional[str] = \"Category:Item\"\n    root: Optional[bool] = True\n    mode: Optional[\n        str\n    ] = \"replace\"  # type 'FetchSchemaMode' requires: 'from __future__ import annotations'\n</code></pre>"},{"location":"osw/#osw.core.OSW.SchemaRegistration","title":"<code>SchemaRegistration</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>dataclass param of register_schema()</p> <p>Attributes:</p> Name Type Description <code>model_cls</code> <code>ModelMetaclass</code> <p>the model class</p> <code>schema_name</code> <code>str</code> <p>the name of the schema</p> <code>schema_bases</code> <code>List[str]</code> <p>list of base schemas (referenced by allOf)</p> Source code in <code>src/osw/core.py</code> <pre><code>class SchemaRegistration(BaseModel):\n\"\"\"\n    dataclass param of register_schema()\n\n    Attributes\n    ----------\n    model_cls:\n        the model class\n    schema_name:\n        the name of the schema\n    schema_bases:\n        list of base schemas (referenced by allOf)\n    \"\"\"\n\n    class Config:\n        arbitrary_types_allowed = True  # allow any class as type\n\n    model_cls: ModelMetaclass\n    schema_uuid = str  # Optional[str] = model_cls.__uuid__\n    schema_name: str  # Optional[str] = model_cls.__name__\n    schema_bases: List[str] = [\"Category:Item\"]\n</code></pre>"},{"location":"osw/#osw.core.OSW.SchemaUnregistration","title":"<code>SchemaUnregistration</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>dataclass param of register_schema()</p> <p>Attributes:</p> Name Type Description <code>model_cls</code> <code>Optional[ModelMetaclass]</code> <p>the model class</p> <code>schema_name</code> <p>the name of the schema</p> <code>schema_bases</code> <p>list of base schemas (referenced by allOf)</p> Source code in <code>src/osw/core.py</code> <pre><code>class SchemaUnregistration(BaseModel):\n\"\"\"\n    dataclass param of register_schema()\n\n    Attributes\n    ----------\n    model_cls:\n        the model class\n    schema_name:\n        the name of the schema\n    schema_bases:\n        list of base schemas (referenced by allOf)\n    \"\"\"\n\n    class Config:\n        arbitrary_types_allowed = True  # allow any class as type\n\n    model_cls: Optional[ModelMetaclass]\n    model_uuid: Optional[str]\n    comment: Optional[str]\n</code></pre>"},{"location":"osw/#osw.core.OSW.delete_entity","title":"<code>delete_entity(entity, comment=None)</code>","text":"<p>Deletes the given entity/entities from the OSW instance.</p> Source code in <code>src/osw/core.py</code> <pre><code>def delete_entity(\n    self, entity: Union[model.OswBaseModel, DeleteEntityParam], comment: str = None\n):\n\"\"\"Deletes the given entity/entities from the OSW instance.\"\"\"\n    if not isinstance(entity, OSW.DeleteEntityParam):\n        if isinstance(entity, list):\n            entity = OSW.DeleteEntityParam(entities=entity)\n        else:\n            entity = OSW.DeleteEntityParam(entities=[entity])\n    if comment is not None:\n        entity.comment = comment\n    if len(entity.entities) &gt;= 5:\n        entity.parallel = True\n\n    def delete_entity_(entity, comment_: str = None):\n\"\"\"Deletes the given entity from the OSW instance.\n\n        Parameters\n        ----------\n        entity:\n            The dataclass instance to delete\n        comment_:\n            Command for the change log, by default None\n        \"\"\"\n        title_ = None\n        namespace_ = None\n        if hasattr(entity, \"meta\") and entity.meta and entity.meta.wiki_page:\n            if entity.meta.wiki_page.title:\n                title_ = entity.meta.wiki_page.title\n            if entity.meta.wiki_page.namespace:\n                namespace_ = entity.meta.wiki_page.namespace\n        if namespace_ is None:\n            namespace_ = get_namespace(entity)\n        if title_ is None:\n            title_ = OSW.get_osw_id(entity.uuid)\n        if namespace_ is None or title_ is None:\n            print(\"Error: Unsupported entity type\")\n            return\n        entity_title = namespace_ + \":\" + title_\n        page = self.site.get_page(WtSite.GetPageParam(titles=[entity_title])).pages[\n            0\n        ]\n\n        if page.exists:\n            page.delete(comment_)\n            print(\"Entity deleted: \" + page.get_url())\n        else:\n            print(f\"Entity '{entity_title}' does not exist!\")\n\n    if entity.parallel:\n        _ = parallelize(\n            delete_entity_,\n            entity.entities,\n            flush_at_end=entity.debug,\n            comment_=entity.comment,\n        )\n    else:\n        _ = [delete_entity_(e, entity.comment) for e in entity.entities]\n</code></pre>"},{"location":"osw/#osw.core.OSW.fetch_schema","title":"<code>fetch_schema(fetchSchemaParam=None)</code>","text":"<p>Loads the given schema from the OSW instance and autogenerates python datasclasses within osw.model.entity from it</p> <p>Parameters:</p> Name Type Description Default <code>fetchSchemaParam</code> <code>FetchSchemaParam</code> <p>See FetchSchemaParam, by default None</p> <code>None</code> Source code in <code>src/osw/core.py</code> <pre><code>def fetch_schema(self, fetchSchemaParam: FetchSchemaParam = None) -&gt; None:\n\"\"\"Loads the given schema from the OSW instance and autogenerates python\n    datasclasses within osw.model.entity from it\n\n    Parameters\n    ----------\n    fetchSchemaParam\n        See FetchSchemaParam, by default None\n    \"\"\"\n    site_cache_state = self.site.get_cache_enabled()\n    self.site.enable_cache()\n    if fetchSchemaParam is None:\n        fetchSchemaParam = OSW.FetchSchemaParam()\n    schema_title = fetchSchemaParam.schema_title\n    root = fetchSchemaParam.root\n    schema_name = schema_title.split(\":\")[-1]\n    page = self.site.get_page(WtSite.GetPageParam(titles=[schema_title])).pages[0]\n    if not page.exists:\n        print(f\"Error: Page {schema_title} does not exist\")\n        return\n    if schema_title.startswith(\"Category:\"):\n        schema_str = json.dumps(page.get_slot_content(\"jsonschema\"))\n    else:\n        schema_str = page.get_content()\n    schema = json.loads(\n        schema_str.replace(\"$ref\", \"dollarref\")\n    )  # '$' is a special char for root object in jsonpath\n    print(f\"Fetch {schema_title}\")\n\n    jsonpath_expr = parse(\"$..dollarref\")\n    for match in jsonpath_expr.find(schema):\n        # value = \"https://\" + self.site._site.host + match.value\n        if match.value.startswith(\"#\"):\n            continue  # skip self references\n        ref_schema_title = match.value.replace(\"/wiki/\", \"\").split(\"?\")[0]\n        ref_schema_name = ref_schema_title.split(\":\")[-1] + \".json\"\n        value = \"\"\n        for i in range(0, schema_name.count(\"/\")):\n            value += \"../\"  # created relative path to top-level schema dir\n        value += ref_schema_name  # create a reference to a local file\n        match.full_path.update_or_create(schema, value)\n        # print(f\"replace {match.value} with {value}\")\n        if (\n            ref_schema_title != schema_title\n        ):  # prevent recursion in case of self references\n            self.fetch_schema(\n                OSW.FetchSchemaParam(schema_title=ref_schema_title, root=False)\n            )  # resolve references recursive\n\n    model_dir_path = os.path.join(\n        os.path.dirname(os.path.abspath(__file__)), \"model\"\n    )  # src/model\n    schema_path = os.path.join(model_dir_path, schema_name + \".json\")\n    os.makedirs(os.path.dirname(schema_path), exist_ok=True)\n    with open(schema_path, \"w\", encoding=\"utf-8\") as f:\n        schema_str = json.dumps(schema, ensure_ascii=False, indent=4).replace(\n            \"dollarref\", \"$ref\"\n        )\n        # print(schema_str)\n        f.write(schema_str)\n\n    # result_model_path = schema_path.replace(\".json\", \".py\")\n    result_model_path = os.path.join(model_dir_path, \"entity.py\")\n    temp_model_path = os.path.join(model_dir_path, \"temp.py\")\n    if root:\n        exec_name = \"datamodel-codegen\"\n        if platform.system() == \"Windows\":\n            exec_name += \".exe\"\n        exec_path = os.path.join(\n            os.path.dirname(os.path.abspath(sys.executable)), exec_name\n        )\n        if not os.path.isfile(exec_path):\n            exec_path = os.path.join(\n                os.path.dirname(os.path.abspath(sys.executable)),\n                \"Scripts\",\n                exec_name,\n            )\n        if not os.path.isfile(exec_path):\n            print(\"Error: datamodel-codegen not found\")\n            return\n        os.system(\n            f\"{exec_path}  \\\n            --input {schema_path} \\\n            --input-file-type jsonschema \\\n            --output {temp_model_path} \\\n            --base-class osw.model.static.OswBaseModel \\\n            --use-default \\\n            --enum-field-as-literal all \\\n            --use-title-as-name \\\n            --use-schema-description \\\n            --use-field-description \\\n            --encoding utf-8 \\\n            --use-double-quotes \\\n            --collapse-root-models \\\n            --reuse-model \\\n        \"\n        )\n        # see https://koxudaxi.github.io/datamodel-code-generator/\n        # --base-class OswBaseModel: use a custom base class\n        # --custom-template-dir src/model/template_data/\n        # --extra-template-data src/model/template_data/extra.json\n        # --use-default: Use default value even if a field is required\n        # --enum-field-as-literal all: prevent 'value is not a valid enumeration member' errors after schema reloading\n        # --use-schema-description: Use schema description to populate class docstring\n        # --use-field-description: Use schema description to populate field docstring\n        # --use-title-as-name: use titles as class names of models, e. g. for the footer templates\n        # --collapse-root-models: Models generated with a root-type field will be merged\n        # into the models using that root-type model, e. g. for Entity.statements\n        # --reuse-model: Re-use models on the field when a module has the model with the same content\n\n        # this is dirty, but required for autocompletion: https://stackoverflow.com/questions/62884543/pydantic-autocompletion-in-vs-code\n        # idealy solved by custom templates in the future: https://github.com/koxudaxi/datamodel-code-generator/issues/860\n\n        content = \"\"\n        with open(temp_model_path, \"r\", encoding=\"utf-8\") as f:\n            content = f.read()\n        os.remove(temp_model_path)\n\n        # Statement and its subclasses are a complex case that needs manual fixing\n\n        # datamodel-codegen &lt;= 0.15.0\n        # make statement classes subclasses of Statement\n        content = re.sub(\n            r\"ObjectStatement\\(OswBaseModel\\)\",\n            r\"ObjectStatement(Statement)\",\n            content,\n        )\n        content = re.sub(\n            r\"DataStatement\\(OswBaseModel\\)\", r\"DataStatement(Statement)\", content\n        )\n        content = re.sub(\n            r\"QuantityStatement\\(OswBaseModel\\)\",\n            r\"QuantityStatement(Statement)\",\n            content,\n        )\n        # make statement lists union of all statement types\n        content = re.sub(\n            r\"List\\[Statement\\]\",\n            r\"List[Union[ObjectStatement, DataStatement, QuantityStatement]]\",\n            content,\n        )\n        # remove Statement class\n        content = re.sub(\n            r\"(class\\s*\"\n            + \"Statement\"\n            + r\"\\s*\\(\\s*\\S*\\s*\\)\\s*:.*\\n[\\s\\S]*?(?:[^\\S\\n]*\\n){3,})\",\n            \"\",\n            content,\n            count=1,\n        )\n        # rename Statement1 to Statement\n        content = re.sub(r\"Statement1\", r\"Statement\", content)\n        # add forward refs\n        content = re.sub(\n            r\"Statement.update_forward_refs\\(\\)\",\n            r\"Statement.update_forward_refs()\\nObjectStatement.update_forward_refs()\\nDataStatement.update_forward_refs()\\nQuantityStatement.update_forward_refs()\",\n            content,\n        )\n        pattern = re.compile(\n            r\"(class\\s*\"\n            + \"Statement\"\n            + r\"\\s*\\(\\s*\\S*\\s*\\)\\s*:.*\\n[\\s\\S]*?(?:[^\\S\\n]*\\n){3,})\"\n        )  # match Statement class definition\n        for cls in re.findall(pattern, content):\n            # remove class\n            content = re.sub(\n                r\"(class\\s*\"\n                + \"Statement\"\n                + r\"\\s*\\(\\s*\\S*\\s*\\)\\s*:.*\\n[\\s\\S]*?(?:[^\\S\\n]*\\n){3,})\",\n                \"\",\n                content,\n                count=1,\n            )\n            content = re.sub(\n                r\"(class\\s*\\S*\\s*\\(\\s*Statement\\s*\\)\\s*:.*\\n)\",\n                cls + r\"\\1\",\n                content,\n                1,\n            )  # insert class definition before first reference\n            break\n\n        # datamodel-codegen &gt; 0.15.0\n        # Rename statement classes (ObjectStatement, DataStatement, QuantityStatement)\n        # content = re.sub(r\"ObjectStatement\", r\"_ObjectStatement\", content)\n        # content = re.sub(r\"DataStatement\", r\"_DataStatement\", content)\n        # content = re.sub(r\"QuantityStatement\", r\"_QuantityStatement\", content)\n        # class Statement1(_ObjectStatement):\n        # content = re.sub(r\"class\\s*\\S*(\\s*\\(\\s*_ObjectStatement\\s*\\))\", r\"class ObjectStatement\\1\", content)\n        # content = re.sub(r\"class\\s*\\S*(\\s*\\(\\s*_DataStatement\\s*\\))\", r\"class DataStatement\\1\", content)\n        # content = re.sub(r\"class\\s*\\S*(\\s*\\(\\s*_QuantityStatement\\s*\\))\", r\"class QuantityStatement\\1\", content)\n        # Union[Statement1, Statement2, Statement3] and Statement&lt;x&gt;.update_forward_refs()\n        # content = re.sub(r\"Statement1\", r\"ObjectStatement\", content)\n        # content = re.sub(r\"Statement2\", r\"DataStatement\", content)\n        # content = re.sub(r\"Statement3\", r\"QuantityStatement\", content)\n\n        if fetchSchemaParam.mode == \"replace\":\n            header = (\n                \"from uuid import uuid4\\n\"\n                \"from typing import Type, TypeVar\\n\"\n                \"from osw.model.static import OswBaseModel, Ontology\\n\"\n                \"\\n\"\n            )\n\n            content = re.sub(\n                r\"(class\\s*\\S*\\s*\\(\\s*OswBaseModel\\s*\\)\\s*:.*\\n)\",\n                header + r\"\\n\\n\\n\\1\",\n                content,\n                1,\n            )  # add header before first class declaration\n\n            content = re.sub(\n                r\"(UUID = Field\\(...)\",\n                r\"UUID = Field(default_factory=uuid4\",\n                content,\n            )  # enable default value for uuid\n            with open(result_model_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(content)\n\n        if fetchSchemaParam.mode == \"append\":\n            org_content = \"\"\n            with open(result_model_path, \"r\", encoding=\"utf-8\") as f:\n                org_content = f.read()\n\n            pattern = re.compile(\n                r\"class\\s*([\\S]*)\\s*\\(\\s*\\S*\\s*\\)\\s*:.*\\n\"\n            )  # match class definition [\\s\\S]*(?:[^\\S\\n]*\\n){2,}\n            for cls in re.findall(pattern, org_content):\n                print(cls)\n                content = re.sub(\n                    r\"(class\\s*\"\n                    + cls\n                    + r\"\\s*\\(\\s*\\S*\\s*\\)\\s*:.*\\n[\\s\\S]*?(?:[^\\S\\n]*\\n){3,})\",\n                    \"\",\n                    content,\n                    count=1,\n                )  # replace duplicated classes\n\n            content = re.sub(\n                r\"(from __future__ import annotations)\", \"\", content, 1\n            )  # remove import statement\n            # print(content)\n            with open(result_model_path, \"a\", encoding=\"utf-8\") as f:\n                f.write(content)\n\n        importlib.reload(model)  # reload the updated module\n        if not site_cache_state:\n            self.site.disable_cache()  # restore original state\n</code></pre>"},{"location":"osw/#osw.core.OSW.get_osw_id","title":"<code>get_osw_id(uuid)</code>  <code>staticmethod</code>","text":"<p>Generates a OSW-ID based on the given uuid by prefixing \"OSW\" and removing all '-' from the uuid-string</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>uuid</code> <p>uuid object, e. g. UUID(\"2ea5b605-c91f-4e5a-9559-3dff79fdd4a5\")</p> required <p>Returns:</p> Type Description <code>    OSW-ID string, e. g. OSW2ea5b605c91f4e5a95593dff79fdd4a5</code> Source code in <code>src/osw/core.py</code> <pre><code>@staticmethod\ndef get_osw_id(uuid: uuid) -&gt; str:\n\"\"\"Generates a OSW-ID based on the given uuid by prefixing \"OSW\" and removing\n    all '-' from the uuid-string\n\n    Parameters\n    ----------\n    uuid\n        uuid object, e. g. UUID(\"2ea5b605-c91f-4e5a-9559-3dff79fdd4a5\")\n\n    Returns\n    -------\n        OSW-ID string, e. g. OSW2ea5b605c91f4e5a95593dff79fdd4a5\n    \"\"\"\n    return \"OSW\" + str(uuid).replace(\"-\", \"\")\n</code></pre>"},{"location":"osw/#osw.core.OSW.get_uuid","title":"<code>get_uuid(osw_id)</code>  <code>staticmethod</code>","text":"<p>Returns the uuid for a given OSW-ID</p> <p>Parameters:</p> Name Type Description Default <code>osw_id</code> <p>OSW-ID string, e. g. OSW2ea5b605c91f4e5a95593dff79fdd4a5</p> required <p>Returns:</p> Type Description <code>    uuid object, e. g. UUID(\"2ea5b605-c91f-4e5a-9559-3dff79fdd4a5\")</code> Source code in <code>src/osw/core.py</code> <pre><code>@staticmethod\ndef get_uuid(osw_id) -&gt; uuid:\n\"\"\"Returns the uuid for a given OSW-ID\n\n    Parameters\n    ----------\n    osw_id\n        OSW-ID string, e. g. OSW2ea5b605c91f4e5a95593dff79fdd4a5\n\n    Returns\n    -------\n        uuid object, e. g. UUID(\"2ea5b605-c91f-4e5a-9559-3dff79fdd4a5\")\n    \"\"\"\n    return UUID(osw_id.replace(\"OSW\", \"\"))\n</code></pre>"},{"location":"osw/#osw.core.OSW.load_entity","title":"<code>load_entity(entity_title)</code>","text":"<p>Loads the entity with the given wiki page name from the OSW instance. Creates an instance of the class specified by the \"type\" attribute, default model.Entity. An instance of model.Entity can be cast to any subclass with .cast(model.) . <p>Parameters:</p> Name Type Description Default <code>entity_title</code> <p>the wiki page name</p> required <p>Returns:</p> Type Description <code>    the dataclass instance</code> Source code in <code>src/osw/core.py</code> <pre><code>def load_entity(self, entity_title) -&gt; model.Entity:\n\"\"\"Loads the entity with the given wiki page name from the OSW instance.\n    Creates an instance of the class specified by the \"type\" attribute, default\n    model.Entity. An instance of model.Entity can be cast to any subclass with\n    .cast(model.&lt;class&gt;) .\n\n    Parameters\n    ----------\n    entity_title\n        the wiki page name\n\n    Returns\n    -------\n        the dataclass instance\n    \"\"\"\n    entity = None\n    schemas = []\n    page = self.site.get_page(WtSite.GetPageParam(titles=[entity_title])).pages[0]\n    jsondata = page.get_slot_content(\"jsondata\")\n    if jsondata:\n        for category in jsondata[\"type\"]:\n            schema = (\n                self.site.get_page(WtSite.GetPageParam(titles=[category]))\n                .pages[0]\n                .get_slot_content(\"jsonschema\")\n            )\n            schemas.append(schema)\n\n    if len(schemas) == 0:\n        print(\"Error: no schema defined\")\n\n    elif len(schemas) == 1:\n        cls = schemas[0][\"title\"]\n        entity = eval(f\"model.{cls}(**jsondata)\")\n\n    else:\n        bases = []\n        for schema in schemas:\n            bases.append(eval(\"model.\" + schema[\"title\"]))\n        cls = create_model(\"Test\", __base__=tuple(bases))\n        entity = cls(**jsondata)\n        entity.meta = model.Meta(\n            wiki_page=model.WikiPage(\n                namespace=namespace_from_full_title(entity_title),\n                title=title_from_full_title(entity_title),\n            )\n        )\n\n    return entity\n</code></pre>"},{"location":"osw/#osw.core.OSW.register_schema","title":"<code>register_schema(schema_registration)</code>","text":"<p>Registers a new or updated schema in OSW by creating the corresponding category page.</p> <p>Parameters:</p> Name Type Description Default <code>schema_registration</code> <code>SchemaRegistration</code> <p>see SchemaRegistration</p> required Source code in <code>src/osw/core.py</code> <pre><code>def register_schema(self, schema_registration: SchemaRegistration):\n\"\"\"Registers a new or updated schema in OSW by creating the corresponding\n    category page.\n\n    Parameters\n    ----------\n    schema_registration\n        see SchemaRegistration\n    \"\"\"\n    entity = schema_registration.model_cls\n\n    jsondata = {}\n    jsondata[\"uuid\"] = schema_registration.schema_uuid\n    jsondata[\"label\"] = {\"text\": schema_registration.schema_name, \"lang\": \"en\"}\n    jsondata[\"subclass_of\"] = schema_registration.schema_bases\n\n    if issubclass(entity, BaseModel):\n        entity_title = \"Category:\" + OSW.get_osw_id(schema_registration.schema_uuid)\n        page = self.site.get_page(WtSite.GetPageParam(titles=[entity_title])).pages[\n            0\n        ]\n\n        page.set_slot_content(\"jsondata\", jsondata)\n\n        # entity = ModelMetaclass(entity.__name__, (BaseModel,), dict(entity.__dict__)) #strips base classes but fiels are already importet\n        schema = json.loads(\n            entity.schema_json(indent=4).replace(\"$ref\", \"dollarref\")\n        )\n\n        jsonpath_expr = parse(\"$..allOf\")\n        # replace local definitions (#/definitions/...) with embedded definitions to prevent resolve errors in json-editor\n        for match in jsonpath_expr.find(schema):\n            result_array = []\n            for subschema in match.value:\n                # pprint(subschema)\n                value = subschema[\"dollarref\"]\n                if value.startswith(\"#\"):\n                    definition_jsonpath_expr = parse(\n                        value.replace(\"#\", \"$\").replace(\"/\", \".\")\n                    )\n                    for def_match in definition_jsonpath_expr.find(schema):\n                        # pprint(def_match.value)\n                        result_array.append(def_match.value)\n                else:\n                    result_array.append(subschema)\n            match.full_path.update_or_create(schema, result_array)\n        if \"definitions\" in schema:\n            del schema[\"definitions\"]\n\n        if \"allOf\" not in schema:\n            schema[\"allOf\"] = []\n        for base in schema_registration.schema_bases:\n            schema[\"allOf\"].append(\n                {\"$ref\": f\"/wiki/{base}?action=raw&amp;slot=jsonschema\"}\n            )\n\n        page.set_slot_content(\"jsonschema\", schema)\n    else:\n        print(\"Error: Unsupported entity type\")\n        return\n\n    page.edit()\n    print(\"Entity stored at \" + page.get_url())\n</code></pre>"},{"location":"osw/#osw.core.OSW.store_entity","title":"<code>store_entity(param)</code>","text":"<p>stores the given dataclass instance as OSW page by calling BaseModel.json()</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>Union[StoreEntityParam, OswBaseModel, List[OswBaseModel]]</code> <p>StoreEntityParam, the dataclass instance or a list of instances</p> required Source code in <code>src/osw/core.py</code> <pre><code>def store_entity(\n    self, param: Union[StoreEntityParam, OswBaseModel, List[OswBaseModel]]\n) -&gt; None:\n\"\"\"stores the given dataclass instance as OSW page by calling BaseModel.json()\n\n    Parameters\n    ----------\n    param:\n        StoreEntityParam, the dataclass instance or a list of instances\n    \"\"\"\n    if isinstance(param, model.Entity):\n        param = OSW.StoreEntityParam(entities=[param])\n    if isinstance(param, list):\n        param = OSW.StoreEntityParam(entities=param)\n    if not isinstance(param.entities, list):\n        param.entities = [param.entities]\n\n    max_index = len(param.entities)\n    if max_index &gt;= 5:\n        param.parallel = True\n\n    meta_category = self.site.get_page(\n        WtSite.GetPageParam(titles=[param.meta_category_title])\n    ).pages[0]\n\n    def store_entity_(\n        entity: model.Entity, namespace_: str = None, index: int = None\n    ) -&gt; None:\n        title_ = get_title(entity)\n        if namespace_ is None:\n            namespace_ = get_namespace(entity)\n        if namespace_ is None or title_ is None:\n            print(\"Error: Unsupported entity type\")\n            return\n        entity_title = namespace_ + \":\" + title_\n        page = self.site.get_page(WtSite.GetPageParam(titles=[entity_title])).pages[\n            0\n        ]\n\n        jsondata = json.loads(\n            entity.json(exclude_none=True)\n        )  # use pydantic serialization, skip none values\n        page.set_slot_content(\"jsondata\", jsondata)\n        page.set_slot_content(\n            \"header\", \"{{#invoke:Entity|header}}\"\n        )  # required for json parsing and header rendering\n        page.set_slot_content(\n            \"footer\", \"{{#invoke:Entity|footer}}\"\n        )  # required for footer rendering\n        if namespace_ == \"Category\":\n            template = meta_category.get_slot_content(\"schema_template\")\n            if template:\n                schema = json.loads(\n                    eval_handlebars_template(\n                        template, jsondata, {\"_page_title\": entity_title}\n                    )\n                )\n                page.set_slot_content(\"jsonschema\", schema)\n        page.edit()\n        if index is None:\n            print(f\"Entity stored at {page.get_url()}.\")\n        else:\n            print(\n                f\"({index + 1}/{max_index}) Entity stored at \" f\"{page.get_url()}.\"\n            )\n\n    if param.parallel:\n        _ = parallelize(\n            store_entity_,\n            param.entities,\n            flush_at_end=param.debug,\n            namespace_=param.namespace,\n        )\n    else:\n        _ = [\n            store_entity_(e, param.namespace, i)\n            for i, e in enumerate(param.entities)\n        ]\n</code></pre>"},{"location":"osw/#osw.core.OSW.unregister_schema","title":"<code>unregister_schema(schema_unregistration)</code>","text":"<p>deletes the corresponding category page</p> <p>Parameters:</p> Name Type Description Default <code>schema_unregistration</code> <code>SchemaUnregistration</code> <p>see SchemaUnregistration</p> required Source code in <code>src/osw/core.py</code> <pre><code>def unregister_schema(self, schema_unregistration: SchemaUnregistration):\n\"\"\"deletes the corresponding category page\n\n    Parameters\n    ----------\n    schema_unregistration\n        see SchemaUnregistration\n    \"\"\"\n    uuid = \"\"\n    if schema_unregistration.model_uuid:\n        uuid = schema_unregistration.model_uuid\n    elif (\n        not uuid\n        and schema_unregistration.model_cls\n        and issubclass(schema_unregistration.model_cls, BaseModel)\n    ):\n        uuid = schema_unregistration.model_cls.__uuid__\n    else:\n        print(\"Error: Neither model nor model id provided\")\n\n    entity_title = \"Category:\" + OSW.get_osw_id(uuid)\n    page = self.site.get_page(WtSite.GetPageParam(titles=[entity_title])).pages[0]\n    page.delete(schema_unregistration.comment)\n</code></pre>"},{"location":"readme/","title":"Readme","text":"<p><code>{include} ../README.md :relative-docs: docs/ :relative-images:</code></p>"},{"location":"tools/","title":"Tools","text":"<p>Collection of helper functions</p>"},{"location":"tools/#osw.wiki_tools.SearchParam","title":"<code>SearchParam</code>","text":"<p>             Bases: <code>OswBaseModel</code></p> <p>Search parameters for semantic and prefix search</p> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>class SearchParam(OswBaseModel):\n\"\"\"Search parameters for semantic and prefix search\"\"\"\n\n    query: Union[str, List[str]]\n    parallel: Optional[bool] = False  # is set to true if query is a list longer than 5\n    debug: Optional[bool] = True\n    limit: Optional[int] = 1000\n\n    # todo: @Simon: Bad style? Better to make it explicit in every function using it?\n    def __init__(self, **data):\n        super().__init__(**data)\n        if isinstance(self.query, str):\n            self.query = [self.query]\n        if len(self.query) &gt; 5:\n            self.parallel = True\n</code></pre>"},{"location":"tools/#osw.wiki_tools.copy_list_of_wiki_pages","title":"<code>copy_list_of_wiki_pages(title_list, site0, site1, overwrite, callback=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>title_list</code> <code>list</code> required <code>site0</code> <code>Site</code> <p>Source site object from mwclient lib</p> required <code>site1</code> <code>Site</code> <p>Target site object from mwclient lib</p> required <code>overwrite</code> <code>bool</code> <p>Whether to overwrite existing pages at target site</p> required <code>callback</code> <code>NoneType or function</code> <p>Function passed over, to perform operation on the titles of the source pages and to be passed as title of the target pages. See examples below. Example functions:     capitalize = lambda x: x.capitalize()     def change_namespace(title, namespace):         if \":\" in namespace:             namespace = namespace.split(\":\")[0]         if \":\" in title:             splits = title.split(\":\")             old_name = splits[1].capitalize()             new_title = namespace + \":\" + old_name         else:             new_title = namespace + \":\" + title.capitalize()         return new_title Examples of passing a function as parameter:     callback = capitalize     callback = lambda x: x.lower()</p> <code>None</code> <p>Returns:</p> Name Type Description <code>results_dict</code> <code>dict</code> <p>Dictionary, containing the results of the copying operations</p> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def copy_list_of_wiki_pages(title_list, site0, site1, overwrite, callback=None):\n\"\"\"\n\n    Parameters\n    ----------\n    title_list : list\n    site0 : mwclient.client.Site\n        Source site object from mwclient lib\n    site1 : mwclient.client.Site\n        Target site object from mwclient lib\n    overwrite : bool\n        Whether to overwrite existing pages at target site\n    callback : NoneType or function\n        Function passed over, to perform operation on the titles of the source pages and\n        to be passed as title of the\n        target pages. See examples below.\n        Example functions:\n            capitalize = lambda x: x.capitalize()\n            def change_namespace(title, namespace):\n                if \":\" in namespace:\n                    namespace = namespace.split(\":\")[0]\n                if \":\" in title:\n                    splits = title.split(\":\")\n                    old_name = splits[1].capitalize()\n                    new_title = namespace + \":\" + old_name\n                else:\n                    new_title = namespace + \":\" + title.capitalize()\n                return new_title\n        Examples of passing a function as parameter:\n            callback = capitalize\n            callback = lambda x: x.lower()\n\n    Returns\n    -------\n    results_dict : dict\n        Dictionary, containing the results of the copying operations\n    \"\"\"\n\n    success_list = list()\n    fail_list = list()\n    for title0 in title_list:\n        if callback is None:\n            title1 = title0\n        else:\n            title1 = callback(title0)\n        success = copy_wiki_page(title0, title1, site0, site1, overwrite)\n        if success:\n            success_list.append(title1)\n        else:\n            fail_list.append(title1)\n    results_dict = {\n        \"Successfully copied pages\": success_list,\n        \"Pages failed to copy\": fail_list,\n    }\n    return results_dict\n</code></pre>"},{"location":"tools/#osw.wiki_tools.copy_wiki_page","title":"<code>copy_wiki_page(title0, title1, site0, site1, overwrite=True)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>title0</code> <code>str</code> <p>Title of the source page</p> required <code>title1</code> <code>str</code> <p>Title of the target page</p> required <code>site0</code> <code>Site</code> <p>Source site object from mwclient lib</p> required <code>site1</code> <code>Site</code> <p>Target site object from mwclient lib</p> required <code>overwrite</code> <code>bool</code> <p>Whether to overwrite existing pages at target site</p> <code>True</code> <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def copy_wiki_page(title0, title1, site0, site1, overwrite=True):\n\"\"\"\n\n    Parameters\n    ----------\n    title0 : str\n        Title of the source page\n    title1 : str\n        Title of the target page\n    site0 : mwclient.client.Site\n        Source site object from mwclient lib\n    site1 : mwclient.client.Site\n        Target site object from mwclient lib\n    overwrite : bool\n        Whether to overwrite existing pages at target site\n\n    Returns\n    -------\n    success: bool\n\n    \"\"\"\n    if title0.lower() == title1.lower() and site0 == site1:\n        # copy on it self = no action necessary\n        success = True\n    else:\n        page0 = site0.pages[title0]\n        content = page0.text()\n        if overwrite:\n            success = create_or_overwrite_wiki_page(title1, content, site1)\n        else:\n            search_result = search_wiki_page(title1, site1)\n            if (\n                search_result[\"Result\"] and search_result[\"Exact match\"]\n            ):  # page already exists\n                success = False\n            else:  # search_result[\"Result\"] == True/False, search_result[\"Exact match\"] == False\n                success = create_or_overwrite_wiki_page(title1, content, site1)\n    return success\n</code></pre>"},{"location":"tools/#osw.wiki_tools.create_flat_content_structure_from_wikitext","title":"<code>create_flat_content_structure_from_wikitext(text, array_mode='force')</code>","text":"<p>Create a flat python dict (aka 'flat_content_structure' = 'wikiJson') representing the content of the page</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>the wiki source text</p> required <code>array_mode</code> <code>str</code> <p>defines how to parse template params array_mode / param     value   value;  value;value     comment 'force':               array   array   array           always create an array 'only_multiple':       literal literal array           create only when more than one value is given 'delimiter_present':   literal array   array           create array if at least one separator char is present</p> <code>'force'</code> <p>Returns:</p> Name Type Description <code>res</code> <code>list</code> <p>(aka 'flat_content_structure' = 'wikiJson')</p> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def create_flat_content_structure_from_wikitext(\n    text: str, array_mode: str = \"force\"\n) -&gt; list:\n\"\"\"Create a flat python dict (aka 'flat_content_structure' = 'wikiJson')\n    representing the content of the page\n\n    Parameters\n    ----------\n    text :\n        the wiki source text\n    array_mode :\n        defines how to parse template params\n        array_mode / param     value   value;  value;value     comment\n        'force':               array   array   array           always create an array\n        'only_multiple':       literal literal array           create only when more than one value is given\n        'delimiter_present':   literal array   array           create array if at least one separator char is present\n\n    Returns\n    -------\n    res :\n        (aka 'flat_content_structure' = 'wikiJson')\n    \"\"\"\n\n    res = []\n    text = text.strip()\n    existing_code = mwparserfromhell.parse(text)\n    t_count = 0\n    for i in range(0, len(existing_code.nodes)):\n        n = existing_code.nodes.pop(\n            0\n        )  # returns first layer of nodes. filter() returns also template args\n        if type(n) is mwparserfromhell.nodes.template.Template:\n            t_count += 1\n            wt = {}\n            # print(f\"Template: {t.name} = {t}\")\n            wt[str(n.name).strip()] = {}\n            for p in n.params:\n                # print(f\"  Param: {p.name} = {p.value} ({type(p.value)})\")\n                wt[str(n.name).strip()][\n                    str(p.name)\n                ] = create_flat_content_structure_from_wikitext(\n                    str(p.value), array_mode\n                )\n            res.append(wt)\n        else:\n            if len(res) == 0 or type(res[-1]) is dict:\n                res.append(\"\")\n            res[-1] = res[-1] + str(n)  # append to previous string if exists\n    # for i, x in enumerate(res):\n    #    if type(x) is str: res[i] = x.strip() #remove whitespace\n    res = [x for x in res if x and not (type(x) is str and x.isspace())]\n    if t_count == 0:\n        res = text\n        values = str(text).strip().split(\";\")\n        if array_mode == \"force\":\n            res = values\n        elif array_mode == \"only_multiple\" and len(values) &gt; 1:\n            res = values\n        elif array_mode == \"separator_present\" and \";\" in text:\n            res = values\n    return res\n</code></pre>"},{"location":"tools/#osw.wiki_tools.create_or_overwrite_wiki_page","title":"<code>create_or_overwrite_wiki_page(title, content, site)</code>","text":"<p>Creates a page with the passed title and content. If the page already exists, the prior content is replaced with the passed content.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the wiki page, e.g., User:Someone1234</p> required <code>content</code> <code>str</code> required <code>site</code> <code>Site</code> <p>Site object from mwclient lib</p> required <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def create_or_overwrite_wiki_page(title, content, site):\n\"\"\"Creates a page with the passed title and content. If the page already exists,\n    the prior content is replaced with the passed content.\n\n    Parameters\n    ----------\n    title : str\n        Title of the wiki page, e.g., User:Someone1234\n    content : str\n    site : mwclient.client.Site\n        Site object from mwclient lib\n\n    Returns\n    -------\n    success : bool\n    \"\"\"\n    target_page = site.pages[title]\n    target_page.edit(content, \"[bot] create page\")\n    success = True\n    return success\n</code></pre>"},{"location":"tools/#osw.wiki_tools.create_or_update_wiki_page_with_template","title":"<code>create_or_update_wiki_page_with_template(title, content, site, overwrite_with_empty=False)</code>","text":"<p>Creates a wiki page with a template included in the content. If the page does already exist, the parameters within the template are update</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the wiki page, e.g., User:Someone1234</p> required <code>content</code> <code>str</code> required <code>site</code> <code>Site</code> <p>Site object from mwclient lib</p> required <code>overwrite_with_empty</code> <code>bool</code> <p>Decided whether a template parameter's value in an preexisting page is overwritten with an empty value</p> <code>False</code> <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def create_or_update_wiki_page_with_template(\n    title, content, site, overwrite_with_empty=False\n):\n\"\"\"Creates a wiki page with a template included in the content. If the page does\n    already exist, the parameters within the template are update\n\n    Parameters\n    ----------\n    title : str\n        Title of the wiki page, e.g., User:Someone1234\n    content : str\n    site : mwclient.client.Site\n        Site object from mwclient lib\n    overwrite_with_empty : bool\n        Decided whether a template parameter's value in an preexisting page is\n        overwritten with an empty value\n\n    Returns\n    -------\n    success : bool\n    \"\"\"\n    search_result = search_wiki_page(title, site)\n    if search_result[\"Result\"]:\n        existing_page = site.pages[title]\n        existing_text = existing_page.text()\n        # update the page's content (template only)\n        updated_content = update_template_within_wikitext(\n            text=existing_text,\n            template_text=content,\n            overwrite_with_empty=overwrite_with_empty,\n        )\n        success = create_or_overwrite_wiki_page(title, updated_content, site)\n    else:\n        # just create the page\n        success = create_or_overwrite_wiki_page(title, content, site)\n    return success\n</code></pre>"},{"location":"tools/#osw.wiki_tools.create_site_object","title":"<code>create_site_object(domain, password_file='', credentials=None)</code>","text":"<pre><code>Parameters\n----------\ndomain :\n    Domain of the OSW instance, as specifed in the yaml file\npassword_file :\n    path to file with &lt;username&gt;\n</code></pre> <p>     credentials :         Dictionary with the credentials (username, password)     Returns     -------     site : mwclient.client.Site         Site object from mwclient lib Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def create_site_object(\n    domain: str, password_file: Union[str, FilePath] = \"\", credentials: dict = None\n) -&gt; mwclient.client.Site:\n\"\"\"\n    Parameters\n    ----------\n    domain :\n        Domain of the OSW instance, as specifed in the yaml file\n    password_file :\n        path to file with &lt;username&gt;\\n&lt;password&gt;\n    credentials :\n        Dictionary with the credentials (username, password)\n    Returns\n    -------\n    site : mwclient.client.Site\n        Site object from mwclient lib\n    \"\"\"\n    domain_dict = {\n        \"wiki-dev\": {\"Address\": \"wiki-dev.open-semantic-lab.org\"},\n        \"onterface\": {\"Address\": \"onterface.open-semantic-lab.org:\"},\n    }\n    if domain in domain_dict.keys():\n        domain = domain_dict[domain][\"Address\"]\n\n    site = mwclient.Site(domain, path=\"/w/\")\n    if credentials is None:\n        credentials = read_credentials_from_yaml(password_file, domain)\n    # else:\n    #     credentials = credentials\n    # Login with dictionary unpacking:\n    # site.login(**credentials)\n    # Explicit login:\n    site.login(username=credentials[\"username\"], password=credentials[\"password\"])\n    del credentials\n    return site\n</code></pre>"},{"location":"tools/#osw.wiki_tools.delete_wiki_page","title":"<code>delete_wiki_page(title, site, reason)</code>","text":"<p>Deletes the wiki page with the passed title, if it was found (exact match!), otherwise returns False</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the wiki page, e.g., User:Someone1234</p> required <code>site</code> <code>Site</code> <p>Site object from mwclient lib</p> required <code>reason</code> <code>str</code> required <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def delete_wiki_page(title, site, reason):\n\"\"\"Deletes the wiki page with the passed title, if it was found (exact match!),\n    otherwise returns False\n\n    Parameters\n    ----------\n    title : str\n        Title of the wiki page, e.g., User:Someone1234\n    site : mwclient.client.Site\n        Site object from mwclient lib\n    reason : str\n\n    Returns\n    -------\n    success : bool\n    \"\"\"\n    try:\n        page = site.pages[title]\n        page.delete(reason=reason, watch=False, unwatch=True, oldimage=False)\n        success = True\n    except mwclient.errors.APIError:\n        success = False\n    return success\n</code></pre>"},{"location":"tools/#osw.wiki_tools.edit_wiki_page_with_content_merge","title":"<code>edit_wiki_page_with_content_merge(title, new_content, site, template_name)</code>","text":"<p>Edits an existing wiki page, while merging the passed new content with the content of the existing page</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the wiki page, e.g., User:Someone1234</p> required <code>new_content</code> <code>str</code> required <code>site</code> <code>Site</code> <p>Site object from mwclient lib</p> required <code>template_name</code> <code>str</code> required <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def edit_wiki_page_with_content_merge(title, new_content, site, template_name):\n\"\"\"Edits an existing wiki page, while merging the passed new content with the\n    content of the existing page\n\n    Parameters\n    ----------\n    title : str\n        Title of the wiki page, e.g., User:Someone1234\n    new_content : str\n    site : mwclient.client.Site\n        Site object from mwclient lib\n    template_name : str\n\n    Returns\n    -------\n    success : bool\n    \"\"\"\n    search_result = search_wiki_page(title, site)\n    if search_result[\"Result\"]:\n        source_page = site.pages[title]\n        source_page_content = source_page.text()\n        # todo: test function\n        new_content = merge_wiki_page_text(\n            new_content, source_page_content, template_name=template_name\n        )\n        target_page = site.pages[title]\n        target_page.edit(new_content, \"[bot] update of page content\")\n        success = True\n    else:\n        success = False\n    return success\n</code></pre>"},{"location":"tools/#osw.wiki_tools.extend_page_list_with_recursive_dependencies","title":"<code>extend_page_list_with_recursive_dependencies(page_list, site)</code>","text":"<p>Finds all included templates, properties and categories for a list of wiki pages and appends them to the list</p> <p>Parameters:</p> Name Type Description Default <code>page_list</code> <code>list or iterable</code> <p>List of pages</p> required <code>site</code> <code>Site</code> <p>Site object from mwclient lib</p> required <p>Returns:</p> Name Type Description <code>page_list</code> <code>list</code> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def extend_page_list_with_recursive_dependencies(page_list, site):\n\"\"\"Finds all included templates, properties and categories for a list of wiki pages\n    and appends them to the list\n\n    Parameters\n    ----------\n    page_list : list or iterable\n        List of pages\n    site : mwclient.client.Site\n        Site object from mwclient lib\n\n    Returns\n    -------\n    page_list : list\n    \"\"\"\n    page_list_iter = copy.deepcopy(page_list)\n    for page in page_list_iter:\n        # we provide the updates page list to prevent a revisit of the pages\n        dependencies = find_dependencies_recursively(\n            page, site, dependencies=page_list, debug=False\n        )\n        page_list.extend(dependencies)\n    page_list = np.unique(page_list)\n    return page_list\n</code></pre>"},{"location":"tools/#osw.wiki_tools.find_dependencies","title":"<code>find_dependencies(wikitext, debug=False)</code>","text":"<p>Finds templates, properties and categories within wikitext</p> <p>Parameters:</p> Name Type Description Default <code>wikitext</code> <code>str</code> required <code>debug</code> <code>bool</code> <p>Whether to print debugging messages</p> <code>False</code> <p>Returns:</p> Name Type Description <code>filtered_dependencies</code> <code>list</code> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def find_dependencies(wikitext, debug=False):\n\"\"\"Finds templates, properties and categories within wikitext\n\n    Parameters\n    ----------\n    wikitext : str\n    debug : bool\n        Whether to print debugging messages\n\n    Returns\n    -------\n    filtered_dependencies : list\n    \"\"\"\n    dependencies = []\n    code = mwparserfromhell.parse(wikitext)\n    for template in code.filter_templates(recursive=True):\n        if template.name.split(\":\")[0].isupper():\n            if debug:\n                print(\"MagicWord: {}\".format(template.name))\n        elif template.name[0] == \"#\":\n            if debug:\n                print(\"ParserFunction: {}\".format(template.name))\n            if \"#set:\" in template.name or \"#declare:\" in template.name:\n                if (\n                    \"=\" in template.name.split(\":\")[1]\n                ):  # in case of '{{#set:HasIdPostfix={{{id_postfix}}} }}'\n                    property_ = \"Property:\" + template.name.split(\":\")[1].split(\"=\")[0]\n                    dependencies.append(property_)\n                    if debug:\n                        print(\"=&gt; {}\".format(property_))\n                for param in template.params:\n                    property_ = \"Property:\" + param.split(\"=\")[0]\n                    dependencies.append(property_)\n                    if debug:\n                        print(\"=&gt; {}\".format(property_))\n        else:\n            if debug:\n                print(\"Template: {}\".format(template.name))\n            template_name = str(template.name)\n            if \":\" not in template.name:\n                template_name = \"Template:\" + template_name\n            dependencies.append(template_name)\n            if debug:\n                print(\"=&gt; {}\".format(template_name))\n    # for tag in code.filter_tags(recursive=True):\n    #    if (debug): print(\"Tag: {}\".format(tag))\n    for link in code.filter_wikilinks(recursive=True):\n        if \"::\" in link:\n            if debug:\n                print(\"Annotation: {}\".format(link))\n            property_ = \"Property:\" + link.split(\"::\")[0].split(\"[[\")[-1]\n            dependencies.append(property_)\n            if debug:\n                print(\"=&gt; {}\".format(property_))\n        if \"Category:\" in link:\n            if debug:\n                print(\"Category: {}\".format(link))\n            category = link.replace(\"[[\", \"\").replace(\"]]\", \"\")\n            dependencies.append(str(category))\n            if debug:\n                print(\"=&gt; {}\".format(category))\n        else:\n            if debug:\n                print(\"Link: {}\".format(link))\n    dependencies = np.unique(dependencies).tolist()  # remove duplicates\n    filtered_dependencies = []  # do not manipulate the iterated object\n    for dependency in dependencies:\n        # ensure no leading or trailing white spaces\n        dependency = dependency.strip()\n        # very frew page titles listed here contain invalid characters \"\\n\"\n        dependency = dependency.replace(\"\\n\", \"\")\n        # see https://www.semantic-mediawiki.org/wiki/Help:Special_properties\n        if \"Property:\" in dependency and (\" \" in dependency or \"_\" in dependency):\n            if debug:\n                print(\n                    \"Info: Remove presumptive built-in property {}\".format(dependency)\n                )\n        else:\n            filtered_dependencies.append(dependency)\n    return filtered_dependencies\n</code></pre>"},{"location":"tools/#osw.wiki_tools.find_dependencies_recursively","title":"<code>find_dependencies_recursively(title, site, dependencies=None, debug=False)</code>","text":"<p>Finds all included templates, properties and categories within a wiki page</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the wiki page, e.g., User:Someone1234</p> required <code>site</code> <code>Site</code> <p>Site object from mwclient lib</p> required <code>dependencies</code> <p>List of already found dependent titles</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Whether to print debugging messages</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dependencies</code> <code>list</code> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def find_dependencies_recursively(title, site, dependencies=None, debug=False):\n\"\"\"Finds all included templates, properties and categories within a wiki page\n\n    Parameters\n    ----------\n    title : str\n        Title of the wiki page, e.g., User:Someone1234\n    site : mwclient.client.Site\n        Site object from mwclient lib\n    dependencies\n        List of already found dependent titles\n    debug : bool\n        Whether to print debugging messages\n\n    Returns\n    -------\n    dependencies : list\n    \"\"\"\n    if dependencies is None:\n        dependencies = []\n    title = title.replace(\"{\", \"\").replace(\"}\", \"\")\n    page = site.pages[title]\n    content = page.text()\n    new_dependencies = find_dependencies(content, debug)\n    for dependency in new_dependencies:\n        if dependency not in dependencies:  # for circular dependencies\n            dependencies.append(dependency)\n            if debug:\n                print(\"Scan nested {}\".format(dependency))\n            find_dependencies_recursively(\n                dependency, site, dependencies=dependencies, debug=debug\n            )\n    return dependencies\n</code></pre>"},{"location":"tools/#osw.wiki_tools.get_file_info_and_usage","title":"<code>get_file_info_and_usage(site, title)</code>","text":"<p>(For 'File' pages only) Get information about the file and its usage</p> <p>Parameters:</p> Name Type Description Default <code>site</code> <code>Site</code> <p>Site object from mwclient lib.</p> required <code>title</code> <code>Union[str, List[str], SearchParam]</code> <p>Title(s) of the wiki page(s) or instance of SearchParam.</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>List[Dict[str, Union[Dict[str, str], List[str]]]]</code> <p>Dictionary with page titles as keys and nested dictionary with keys 'info' and 'usage'.</p>"},{"location":"tools/#osw.wiki_tools.get_file_info_and_usage--notes","title":"Notes","text":"<p>Query to reproduce:     action=query     format=json     prop=imageinfo|fileusage     titles=File%3AOSW857d85031d85425aa94db8b4720e84b7.png     &amp;iiprop=timestamp%7Cuser&amp;fulimit=5000\"</p>"},{"location":"tools/#osw.wiki_tools.get_file_info_and_usage--resources","title":"Resources","text":"<p>Use the sandbox to design and test the queries: https://demo.open-semantic-lab.org/wiki/Special:ApiSandbox</p> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def get_file_info_and_usage(\n    site: mwclient.client.Site, title: Union[str, List[str], SearchParam]\n) -&gt; List[Dict[str, Union[Dict[str, str], List[str]]]]:\n\"\"\"(For 'File' pages only) Get information about the file and its usage\n\n    Parameters\n    ----------\n    site:\n        Site object from mwclient lib.\n    title:\n        Title(s) of the wiki page(s) or instance of SearchParam.\n\n    Returns\n    -------\n    result:\n        Dictionary with page titles as keys and nested dictionary with keys 'info' and\n        'usage'.\n\n    Notes\n    -----\n    Query to reproduce:\n        action=query\n        format=json\n        prop=imageinfo|fileusage\n        titles=File%3AOSW857d85031d85425aa94db8b4720e84b7.png\n        &amp;iiprop=timestamp%7Cuser&amp;fulimit=5000\"\n\n    Resources\n    ---------\n    Use the sandbox to design and test the queries:\n    https://demo.open-semantic-lab.org/wiki/Special:ApiSandbox\n    \"\"\"\n    if isinstance(title, str):\n        query = SearchParam(query=[title], debug=False)\n    elif isinstance(title, list):\n        query = SearchParam(query=title, debug=False)\n    else:  # SearchParam\n        query = title\n    if len(query.query) &gt; 5:\n        query.parallel = True\n\n    def get_file_info_and_usage_(single_title):\n        api_request_result = site.api(\n            action=\"query\",\n            format=\"json\",\n            prop=\"imageinfo|fileusage\",\n            titles=single_title,\n            iiprop=\"timestamp|user\",\n            fulimit=query.limit,\n        )\n        using_pages = []\n        file_info = {\n            \"title\": single_title,\n            \"author\": \"File not found or no creation logged\",\n            \"timestamp\": \"File not found or no creation logged\",\n            \"editor\": [],\n            \"editing_timestamp\": [],\n        }\n\n        if len(api_request_result[\"query\"][\"pages\"]) == 0:\n            if query.debug:\n                print(f\"Page not found: '{single_title}'!\")\n        else:\n            image_info: List[Dict[str, str]] = []\n            file_usage: List[Dict[str, Union[str, int]]] = []\n            for page_id, page_dict in api_request_result[\"query\"][\"pages\"].items():\n                if page_dict[\"title\"] == single_title:\n                    image_info = page_dict.get(\"imageinfo\", [])\n                    file_usage = page_dict.get(\"fileusage\", [])\n            if len(image_info) != 0:\n                file_info[\"author\"] = image_info[0][\"user\"]\n                file_info[\"timestamp\"] = image_info[0][\"timestamp\"]\n                for ii in image_info:\n                    file_info[\"editor\"].append(ii[\"user\"])\n                    file_info[\"editing_timestamp\"].append(ii[\"timestamp\"])\n            if file_usage is not None:\n                for fu_page_dict in file_usage:\n                    using_pages.append(fu_page_dict[\"title\"])\n            if query.debug:\n                # todo: find out why this message is printed (sometimes) when using the\n                #  redirect,  which messes up the Progressbar\n                #  printed messages do not appear in the MessageBuffer\n                print(f\"File info for '{single_title}' retrieved.\")\n        return {\"info\": file_info, \"usage\": using_pages}\n\n    if query.parallel:\n        api_request_results = parallelize(\n            func=get_file_info_and_usage_,\n            iterable=query.query,\n            flush_at_end=query.debug,\n        )\n    else:\n        api_request_results = [\n            get_file_info_and_usage_(single_title=st) for st in query.query\n        ]\n\n    return api_request_results\n</code></pre>"},{"location":"tools/#osw.wiki_tools.get_wikitext_from_flat_content_dict","title":"<code>get_wikitext_from_flat_content_dict(d)</code>","text":"<p>Create wiki source text from a flat python dict representing a wiki template</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>flat python dict e.g.: {\"HeaderTemplate\": {\"param\": \"value\"}}</p> required <p>Returns:</p> Name Type Description <code>wt</code> <code>str</code> <p>wiki text</p> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def get_wikitext_from_flat_content_dict(d: dict) -&gt; str:\n\"\"\"Create wiki source text from a flat python dict representing a wiki template\n\n    Parameters\n    ----------\n    d :\n        flat python dict\n        e.g.: {\"HeaderTemplate\": {\"param\": \"value\"}}\n\n    Returns\n    -------\n    wt :\n        wiki text\n    \"\"\"\n    wt = \"\"\n    for key, value in d.items():\n        # print(\"key: {}, valuetype: {}, value: {}\".format(key, type(value), \"\"))\n        if isinstance(value, dict):\n            # print(\"dict\")\n            wt += \"{{\" + key\n            wt += get_wikitext_from_flat_content_dict(value)\n            wt += \"\\n}}\"\n        elif isinstance(value, list):\n            # print(\"list\")\n            wt += \"\\n|{}=\".format(key)\n            string_index = 0\n            for index, element in enumerate(value):\n                if isinstance(element, dict):\n                    wt += get_wikitext_from_flat_content_dict(element)\n                    # wt += \"\\n{{\" + element\n                    # wt += get_wikitext_from_dict(element)\n                    # wt += \"\\n}}\"\n                else:\n                    if string_index != index:\n                        print(\n                            f\"Warning: template param '{key}' has mixed template/\"\n                            f\"string values: {value}\"\n                        )\n                    if string_index &gt; 0 and element and not element.strip().isspace():\n                        wt += \";\"\n                    wt += element\n                    string_index += 1\n        else:\n            # print(\"literal\")\n            wt += \"\\n|{}={}\".format(key, value)\n    return wt\n</code></pre>"},{"location":"tools/#osw.wiki_tools.get_wikitext_from_flat_content_structure","title":"<code>get_wikitext_from_flat_content_structure(content)</code>","text":"<p>Create wiki source text from the content list (aka 'flat_content_structure' = 'wikiJson') of the page</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>list</code> <p>content list, mixed objects (templates) and free text (aka 'flat_content_structure' = 'wikiJson') e.g.: [{\"HeaderTemplate\": {\"param\": \"value\"}}, \"freetext\",        {\"FooterTemplate\": {\"param2\": \"value\"}}]</p> required <p>Returns:</p> Name Type Description <code>wt</code> <code>wiki text</code> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def get_wikitext_from_flat_content_structure(content):\n\"\"\"Create wiki source text from the content list (aka 'flat_content_structure' =\n    'wikiJson') of the page\n\n    Parameters\n    ----------\n    content : list\n        content list, mixed objects (templates) and free text\n        (aka 'flat_content_structure' = 'wikiJson')\n        e.g.: [{\"HeaderTemplate\": {\"param\": \"value\"}}, \"freetext\",\n               {\"FooterTemplate\": {\"param2\": \"value\"}}]\n\n    Returns\n    -------\n    wt : wiki text\n    \"\"\"\n    wt = \"\"\n    for content_element in content:\n        if isinstance(content_element, dict):\n            wt += get_wikitext_from_flat_content_dict(content_element)\n        elif isinstance(content_element, str):\n            wt += content_element  # \"\\n\" + content_element\n        else:\n            print(\n                \"Error: content element is not dict or string: {}\".format(\n                    content_element\n                )\n            )\n    return wt\n</code></pre>"},{"location":"tools/#osw.wiki_tools.merge_wiki_page_text","title":"<code>merge_wiki_page_text(text1, text2, template_name, subtemplate_param='', subtemplate_name='')</code>","text":"<p>Not fully tested function!</p> <p>Parameters:</p> Name Type Description Default <code>text1</code> required <code>text2</code> required <code>template_name</code> required <code>subtemplate_param</code> <code>''</code> <code>subtemplate_name</code> <code>''</code> <p>Returns:</p> Name Type Description <code>non_empty_lines</code> <code>str</code> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def merge_wiki_page_text(\n    text1, text2, template_name, subtemplate_param=\"\", subtemplate_name=\"\"\n):\n\"\"\"Not fully tested function!\n\n    Parameters\n    ----------\n    text1\n    text2\n    template_name\n    subtemplate_param\n    subtemplate_name\n\n    Returns\n    -------\n    non_empty_lines : str\n    \"\"\"\n\n    if text1 == text2:\n        return text1\n    if text1 == \"\":\n        return text2\n    if text2 == \"\":\n        return text1\n    code1 = mwparserfromhell.parse(text1)\n    code2 = mwparserfromhell.parse(text2)\n    r1 = []\n    r2 = []\n    for template in code1.filter_templates(recursive=True):\n        if template.name.matches(template_name):\n            t1 = template\n        if template.name.matches(subtemplate_name):\n            r1.append(template)\n    for template in code2.filter_templates(recursive=True):\n        if template.name.matches(template_name):\n            t2 = template\n        if template.name.matches(subtemplate_name):\n            r2.append(template)\n    # print(\"T1: \" + str(t1))\n    # print(\"T2: \" + str(t2))\n    for p in t2.params:\n        if not t1.has(p.name):\n            t1.add(p.name, p.value)\n    if subtemplate_param != \"\":\n        t1.remove(subtemplate_param)\n        for rel2 in r2:\n            exists = False\n            for rel1 in r1:\n                all_params_equal = True\n                for p in rel2.params:\n                    if rel1.has(p.name):\n                        if not rel1.get(p.name).value.matches(rel2.get(p.name).value):\n                            all_params_equal = False\n                        # print(\"Compare {}:{} with :{} -&gt; res={}\".format(p.name,\n                        #       rel1.get(p.name).value,rel2.get(p.name).value,\n                        #       rel1.get(p.name).value.matches(rel2.get(p.name).value)))\n                    else:\n                        all_params_equal = False\n                if all_params_equal:\n                    exists = True\n            if not exists:\n                r1.append(rel2)\n        r1string = \"\"\n        for rel1 in r1:\n            r1string += \"\\r\\n   \" + str(rel1)\n        t1.add(subtemplate_param, r1string)\n    # print(\"Tmerged: \" + str(t1))\n    non_empty_lines = \"\\n\".join(\n        [ll.rstrip() for ll in str(t1).splitlines() if ll.strip()]\n    )\n    return non_empty_lines\n</code></pre>"},{"location":"tools/#osw.wiki_tools.prefix_search","title":"<code>prefix_search(site, text)</code>","text":"<p>Standard query. Equivalent to the following mediawiki API call api.php?action=query&amp;list=prefixsearch&amp;pssearch=Star Wars</p> <p>Parameters:</p> Name Type Description Default <code>site</code> <code>Site</code> <p>Site object from mwclient lib</p> required <code>text</code> <code>Union[str, SearchParam]</code> <p>Query text or instance of SearchParam</p> required <p>Returns:</p> Name Type Description <code>page_list</code> <code>List[str]</code> <p>List of page titles</p> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def prefix_search(\n    site: mwclient.client.Site, text: Union[str, SearchParam]\n) -&gt; List[str]:\n\"\"\"Standard query. Equivalent to the following mediawiki API call\n    api.php?action=query&amp;list=prefixsearch&amp;pssearch=Star Wars\n\n    Parameters\n    ----------\n    site :\n        Site object from mwclient lib\n    text :\n        Query text or instance of SearchParam\n\n    Returns\n    -------\n    page_list :\n        List of page titles\n    \"\"\"\n    if isinstance(text, str):\n        query = SearchParam(query=[text])\n    elif isinstance(text, list):\n        query = SearchParam(query=text)\n    else:\n        query = text\n    if len(text.query) &gt; 5:\n        query.parallel = True\n\n    def prefix_search_(single_text):\n        page_list = list()\n        result = site.api(\n            \"query\",\n            list=\"prefixsearch\",\n            pssearch=single_text,\n            pslimit=query.limit,\n            format=\"json\",\n        )\n        if len(result[\"query\"][\"prefixsearch\"]) == 0:\n            if query.debug:\n                print(\"No results\")\n        else:\n            for page in result[\"query\"][\"prefixsearch\"]:\n                title = page[\"title\"]\n                if query.debug:\n                    print(title)\n                page_list.append(title)\n        return page_list\n\n    if query.parallel:\n        query_results = parallelize(\n            func=prefix_search_, iterable=query.query, flush_at_end=query.debug\n        )\n    else:\n        query_results = [prefix_search_(single_text=sq) for sq in query.query]\n\n    return [item for sublist in query_results for item in sublist]\n</code></pre>"},{"location":"tools/#osw.wiki_tools.read_credentials_from_yaml","title":"<code>read_credentials_from_yaml(password_file, domain=None)</code>","text":"<p>Reads credentials from a yaml file</p> <p>Parameters:</p> Name Type Description Default <code>password_file</code> <code>Union[str, FilePath]</code> <p>Path to the yaml file with the credentials.</p> required <code>domain</code> <code>str</code> <p>Domain of the OSW instance, as specifed in the yaml file.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>credentials</code> <code>dict</code> <p>Dictionary with the credentials, expected to contain keys 'username' and 'password'.</p> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def read_credentials_from_yaml(\n    password_file: Union[str, FilePath], domain: str = None\n) -&gt; dict:\n\"\"\"Reads credentials from a yaml file\n\n    Parameters\n    ----------\n    password_file :\n        Path to the yaml file with the credentials.\n    domain:\n        Domain of the OSW instance, as specifed in the yaml file.\n\n    Returns\n    -------\n    credentials :\n        Dictionary with the credentials, expected to\n        contain keys 'username' and 'password'.\n    \"\"\"\n    if password_file != \"\":\n        with open(password_file, \"r\") as stream:\n            try:\n                accounts = yaml.safe_load(stream)\n                if domain is not None and domain in accounts.keys():\n                    domain = domain\n                elif len(accounts.keys()) &gt; 0:\n                    domain = list(accounts.keys())[0]\n                    if len(accounts.keys()) &gt; 0:\n                        domain = list(accounts.keys())[0]\n                user = accounts[domain][\"username\"]\n                password = accounts[domain][\"password\"]\n            except yaml.YAMLError as exc:\n                print(exc)\n    else:\n        user = input(\"Enter bot username (username@botname)\")\n        password = getpass.getpass(\"Enter bot password\")\n    return {\"username\": user, \"password\": password}\n</code></pre>"},{"location":"tools/#osw.wiki_tools.read_domains_from_credentials_file","title":"<code>read_domains_from_credentials_file(credentials_file_path)</code>","text":"<p>Reads domains and credentials from a yaml file</p> <p>Parameters:</p> Name Type Description Default <code>credentials_file_path</code> <code>Union[str, FilePath]</code> <p>Path to the yaml file with the credentials</p> required Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def read_domains_from_credentials_file(\n    credentials_file_path: Union[str, FilePath]\n) -&gt; Tuple[List[str], Dict[str, Dict[str, str]]]:\n\"\"\"Reads domains and credentials from a yaml file\n\n    Parameters\n    ----------\n    credentials_file_path\n        Path to the yaml file with the credentials\n\n    Returns\n    -------\n\n    \"\"\"\n    with open(credentials_file_path, \"r\") as stream_:\n        try:\n            accounts_dict = yaml.safe_load(stream_)\n            domains_list = list(accounts_dict.keys())\n            if len(domains_list) == 0:\n                raise ValueError(\"No domain found in accounts.pwd.yaml!\")\n            return domains_list, accounts_dict\n        except yaml.YAMLError as exc_:\n            print(exc_)\n</code></pre>"},{"location":"tools/#osw.wiki_tools.schemaJson2WikiJson","title":"<code>schemaJson2WikiJson(schemaJson, isRoot=True)</code>","text":"<p>Create content representation of a page (aka 'flat_content_structure' = 'wikiJson') from the osl schema-compatible json</p> <p>Parameters:</p> Name Type Description Default <code>schemaJson</code> <code>dict</code> <p>schema-compatible json e.g.: {\"osl_template\": \"HeaderTemplate\", \"param\": \"value\",        \"osl_wikitext\": \"freetext\",        \"osl_footer\": {\"osl_template\": \"FooterTemplate\", \"param2\": \"value2\"}}</p> required <p>isRoot: boolean     indicates first call in recursion</p> <p>Returns:</p> Name Type Description <code>wikiJson</code> <code>list</code> <p>content list, mixed objects (templates) and free text (aka 'flat_content_structure' = 'wikiJson') e.g.: [{\"HeaderTemplate\": {\"param\": \"value\"}}, \"freetext\",        {\"FooterTemplate\": {\"param2\": \"value\"}}]</p> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def schemaJson2WikiJson(schemaJson, isRoot=True):\n\"\"\"Create content representation of a page\n    (aka 'flat_content_structure' = 'wikiJson') from the osl schema-compatible json\n\n    Parameters\n    ----------\n    schemaJson : dict\n        schema-compatible json\n        e.g.: {\"osl_template\": \"HeaderTemplate\", \"param\": \"value\",\n               \"osl_wikitext\": \"freetext\",\n               \"osl_footer\": {\"osl_template\": \"FooterTemplate\", \"param2\": \"value2\"}}\n\n    isRoot: boolean\n        indicates first call in recursion\n\n    Returns\n    -------\n    wikiJson : list\n        content list, mixed objects (templates) and free text\n        (aka 'flat_content_structure' = 'wikiJson')\n        e.g.: [{\"HeaderTemplate\": {\"param\": \"value\"}}, \"freetext\",\n               {\"FooterTemplate\": {\"param2\": \"value\"}}]\n    \"\"\"\n    wikiJson = [{}, \"\", {}]\n    # header, freetext, footer\n    template = \"\"\n    footer_template = \"\"\n    if \"osl_template\" in schemaJson:\n        template = schemaJson[\"osl_template\"]\n        wikiJson[0][template] = {}\n    else:\n        print(\n            \"Error: Mandatory property 'osl_template' not found in schemaJson\",\n            schemaJson,\n        )\n        return\n\n    if \"osl_wikitext\" in schemaJson:\n        wikiJson[1] = schemaJson[\"osl_wikitext\"]\n    if \"osl_footer\" in schemaJson:\n        wikiJson[2] = schemaJson2WikiJson(schemaJson[\"osl_footer\"], False)[0]\n        footer_template = schemaJson[\"osl_footer\"][\"osl_template\"]\n        wikiJson[2][footer_template][\"extensions\"] = []\n\n    for key in schemaJson:\n        if (\n            key.startswith(\"_\")\n            or key.startswith(\"osl_template\")\n            or key.startswith(\"osl_wikitext\")\n            or key.startswith(\"osl_footer\")\n        ):\n            continue  # exclude private and reserved keywords\n        if schemaJson[key] is None:\n            continue\n        if isinstance(schemaJson[key], list):\n            wikiJson[0][template][key] = []\n            for subSchemaJson in schemaJson[key]:\n                subWikiJson = schemaJson2WikiJson(subSchemaJson, False)\n                wikiJson[0][template][key].append(subWikiJson[0])\n                if key == \"extensions\":\n                    wikiJson[2][footer_template][\"extensions\"].append(subWikiJson[2])\n\n        elif isinstance(schemaJson[key], dict):\n            subWikiJson = schemaJson2WikiJson(schemaJson[key], False)\n            wikiJson[0][template][key] = [subWikiJson[0]]\n        else:\n            wikiJson[0][template][key] = schemaJson[key]\n\n    return wikiJson\n</code></pre>"},{"location":"tools/#osw.wiki_tools.search_redirection_sources","title":"<code>search_redirection_sources(site, target_title, debug=False)</code>","text":"<p>Returns a list of pages redirecting to the page with target_title per #REDIRECT [[target]] syntax</p> <p>Parameters:</p> Name Type Description Default <code>site</code> <code>Site</code> <p>Site object from mwclient lib</p> required <code>target_title</code> <code>str</code> <p>Title of the target wiki page</p> required <code>debug</code> <code>bool</code> <p>Whether to print debugging messages</p> <code>False</code> <p>Returns:</p> Name Type Description <code>page_list</code> <code>list of pages redirecting to the page with target_title</code> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def search_redirection_sources(\n    site: mwclient.client.Site, target_title: str, debug: bool = False\n):\n\"\"\"Returns a list of pages redirecting to the page with target_title per #REDIRECT\n    [[target]] syntax\n\n    Parameters\n    ----------\n    site :\n        Site object from mwclient lib\n    target_title :\n        Title of the target wiki page\n    debug:\n        Whether to print debugging messages\n\n    Returns\n    -------\n    page_list : list of pages redirecting to the page with target_title\n    \"\"\"\n    page_list = []\n    result = site.api(\"query\", titles=target_title, prop=\"redirects\", format=\"json\")\n    if len(result[\"query\"][\"pages\"]) == 0:\n        if debug:\n            print(\"No results\")\n    else:\n        for page in result[\"query\"][\"pages\"]:\n            if \"redirects\" not in result[\"query\"][\"pages\"][page]:\n                if debug:\n                    print(\"No results\")\n            else:\n                for redirecting_source in result[\"query\"][\"pages\"][page][\"redirects\"]:\n                    title = redirecting_source[\"title\"]\n                    page_list.append(title)\n    return page_list\n</code></pre>"},{"location":"tools/#osw.wiki_tools.search_wiki_page","title":"<code>search_wiki_page(title, site)</code>","text":"<p>Page search wrapper that adds exact match functionality with ignore-case on top of the  prefix_search()'s functionality.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the wiki page, e.g., User:Someone1234</p> required <code>site</code> <code>Site</code> <p>Site object from mwclient lib</p> required <p>Returns:</p> Name Type Description <code>result_dict</code> <code>dict</code> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def search_wiki_page(title: str, site: mwclient.client.Site):\n\"\"\"Page search wrapper that adds exact match functionality with ignore-case on\n    top of the  prefix_search()'s functionality.\n\n    Parameters\n    ----------\n    title :\n        Title of the wiki page, e.g., User:Someone1234\n    site :\n        Site object from mwclient lib\n\n    Returns\n    -------\n    result_dict : dict\n    \"\"\"\n    result = site.api(\n        \"query\", list=\"prefixsearch\", pssearch=title, pslimit=1000, format=\"json\"\n    )\n    if len(result[\"query\"][\"prefixsearch\"]) == 0:\n        return {\"Result\": False, \"List\": list()}\n    else:\n        exact_match = False\n        page_title_list = list()\n        for page in result[\"query\"][\"prefixsearch\"]:\n            page_title = page[\"title\"]\n            page_title_list.append(page_title)\n            if page_title.lower() == title.lower():\n                exact_match = True\n        result_dict = {\n            \"Result\": True,\n            \"List\": page_title_list,\n            \"Exact match\": exact_match,\n        }\n        return result_dict\n</code></pre>"},{"location":"tools/#osw.wiki_tools.semantic_search","title":"<code>semantic_search(site, query)</code>","text":"<p>Semantic query</p> <p>Parameters:</p> Name Type Description Default <code>site</code> <code>Site</code> <p>Site object from mwclient lib</p> required <code>query</code> <code>Union[str, List[str], SearchParam]</code> <p>(List of) query text(s) or instance of SearchParam</p> required <p>Returns:</p> Name Type Description <code>page_list</code> <code>List[str]</code> <p>List of page titles</p> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def semantic_search(\n    site: mwclient.client.Site, query: Union[str, List[str], SearchParam]\n) -&gt; List[str]:\n\"\"\"Semantic query\n\n    Parameters\n    ----------\n    site :\n        Site object from mwclient lib\n    query :\n        (List of) query text(s) or instance of SearchParam\n\n    Returns\n    -------\n    page_list:\n        List of page titles\n    \"\"\"\n    if isinstance(query, str):\n        query = SearchParam(query=[query])\n    elif isinstance(query, list):\n        query = SearchParam(query=query)\n    if len(query.query) &gt; 5:\n        query.parallel = True\n\n    def semantic_search_(single_query):\n        page_list = list()\n        single_query += f\"|limit={query.limit}\"\n        result = site.api(\"ask\", query=single_query, format=\"json\")\n        if len(result[\"query\"][\"results\"]) == 0:\n            if query.debug:\n                print(\"Query '{}' returned no results\".format(single_query))\n        else:\n            if query.debug:\n                print(\n                    \"Query '{}' returned {} results\".format(\n                        single_query, len(result[\"query\"][\"results\"])\n                    )\n                )\n            for page in result[\"query\"][\"results\"].values():\n                # why do we do the following?\n                if \"printouts\" in page:\n                    title = page[\"fulltext\"]\n                    if \"#\" not in title and query.debug:\n                        print(title)\n                        # original position of \"page_list.append(title)\" line\n                    page_list.append(title)\n        return page_list\n\n    if query.parallel:\n        query_results = parallelize(\n            func=semantic_search_, iterable=query.query, flush_at_end=query.debug\n        )\n    else:\n        query_results = [semantic_search_(single_query=sq) for sq in query.query]\n\n    return [item for sublist in query_results for item in sublist]\n</code></pre>"},{"location":"tools/#osw.wiki_tools.update_template_within_wikitext","title":"<code>update_template_within_wikitext(text, template_text, delete=False, remove_empty_lines=False, overwrite_with_empty=False)</code>","text":"<p>Updates the template parameters in an existing wiki  with a provided new  <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The existing text</p> required <code>template_text</code> <code>str</code> <p>The template text with new data</p> required <code>delete</code> <code>bool</code> <p>If true, params not defined in  get removed from  <code>False</code> <code>remove_empty_lines</code> <code>bool</code> <p>If true, function will clean-up empty lines within the template code created by the underlying mwparserfromhell lib (wanted), but also within the wiki text around it (unwanted)</p> <code>False</code> <code>overwrite_with_empty</code> <code>bool</code> <p>If true, parameters in the existing template will be overwritten even if the parameter value in the template_text is empty</p> <code>False</code> <p>Returns:</p> Name Type Description <code>new_text</code> <code>str</code> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def update_template_within_wikitext(\n    text,\n    template_text,\n    delete=False,\n    remove_empty_lines=False,\n    overwrite_with_empty=False,\n):\n\"\"\"Updates the template parameters in an existing wiki &lt;text&gt; with a provided new\n    &lt;template_text&gt;\n\n    Parameters\n    ----------\n    text : str\n        The existing text\n    template_text : str\n        The template text with new data\n    delete : bool\n        If true, params not defined in &lt;template_text&gt; get removed from &lt;text&gt;\n    remove_empty_lines : bool\n        If true, function will clean-up empty lines within the template code created by\n        the underlying mwparserfromhell lib (wanted), but also within the wiki text\n        around it (unwanted)\n    overwrite_with_empty : bool\n        If true, parameters in the existing template will be overwritten even if the\n        parameter value in the template_text is empty\n\n    Returns\n    -------\n    new_text : str\n    \"\"\"\n    if template_text == text:\n        return template_text\n    if template_text == \"\":\n        return text\n    if text == \"\":\n        return template_text\n    new_code = mwparserfromhell.parse(template_text)\n    new_template = new_code.filter_templates()[0]\n    existing_code = mwparserfromhell.parse(text)\n    template_names_matched = False\n    for template in existing_code.filter_templates(recursive=True):\n        if template.name.matches(new_template.name):\n            existing_template = template\n            template_names_matched = True\n            break\n    if template_names_matched:\n        for p in new_template.params:\n            if existing_template.has(p.name):\n                if p.value != \"\" or overwrite_with_empty:\n                    existing_template.get(p.name).value = p.value\n            else:\n                existing_template.add(p.name, p.value)\n        if delete:\n            for p in existing_template.params:\n                if not new_template.has(p.name):\n                    existing_template.remove(p)\n    else:  # the original text did not contain a matching template\n        # options:\n        # 1) include the new template\n        # 2) replace the existing template - but what if multiple tempaltes exist on\n        #    that page?\n        pass\n    # print(\"Tmerged: \\n\" + str(existing_template))\n    # print(\"Text merged: \" + str(existing_code))\n    new_text = str(existing_code)\n    # this will cleanup empty lines within the template code (wanted), but also within\n    # the wiki text around it (unwanted)\n    if remove_empty_lines:\n        new_text = \"\\n\".join(\n            [ll.rstrip() for ll in str(new_text).splitlines() if ll.strip()]\n        )\n    return new_text\n</code></pre>"},{"location":"tools/#osw.wiki_tools.wikiJson2SchemaJson","title":"<code>wikiJson2SchemaJson(schema, wikiJson)</code>","text":"<p>Create osl schema-compatible json from the content representation of a page (aka 'flat_content_structure' = 'wikiJson')</p> <p>Parameters:</p> Name Type Description Default <code>wikiJson</code> <code>list</code> <p>content list, mixed objects (templates) and free text (aka 'flat_content_structure' = 'wikiJson') e.g.: [{\"HeaderTemplate\": {\"param\": \"value\"}}, \"freetext\",        {\"FooterTemplate\": {\"param2\": \"value\"}}]</p> required <p>Returns:</p> Name Type Description <code>schemaJson</code> <code>dict</code> <p>schema-compatible json e.g.: {\"osl_template\": \"HeaderTemplate\", \"param\": \"value\",        \"osl_wikitext\": \"freetext\",        \"osl_footer\": {\"osl_template\": \"FooterTemplate\",                       \"param2\": \"value2\"}}</p> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def wikiJson2SchemaJson(schema, wikiJson):\n\"\"\"Create osl schema-compatible json from the content representation of a page\n    (aka 'flat_content_structure' = 'wikiJson')\n\n    Parameters\n    ----------\n    wikiJson : list\n        content list, mixed objects (templates) and free text\n        (aka 'flat_content_structure' = 'wikiJson')\n        e.g.: [{\"HeaderTemplate\": {\"param\": \"value\"}}, \"freetext\",\n               {\"FooterTemplate\": {\"param2\": \"value\"}}]\n\n    Returns\n    -------\n    schemaJson : dict\n        schema-compatible json\n        e.g.: {\"osl_template\": \"HeaderTemplate\", \"param\": \"value\",\n               \"osl_wikitext\": \"freetext\",\n               \"osl_footer\": {\"osl_template\": \"FooterTemplate\",\n                              \"param2\": \"value2\"}}\n    \"\"\"\n    schemaJson = {}\n    if (\n        not isinstance(wikiJson[0], dict)\n        or not isinstance(wikiJson[1], str)\n        or not isinstance(wikiJson[2], dict)\n    ):\n        print(\"Error: Invalid wikiJson:\", wikiJson)\n        return schemaJson\n\n    schemaJson = wikiJson2SchemaJsonRecursion(schema, wikiJson[0], wikiJson[2])\n    schemaJson[\"osl_wikitext\"] = wikiJson[1]\n    return schemaJson\n</code></pre>"},{"location":"tools/#osw.wiki_tools.wikiJson2SchemaJsonRecursion","title":"<code>wikiJson2SchemaJsonRecursion(schema, wikiJson, footerWikiJson=None)</code>","text":"<p>internal recursion function of wikiJson2SchemaJson()</p> <p>Parameters:</p> Name Type Description Default <code>wikiJson</code> <code>list</code> <p>wiki template representation e.g.: {\"HeaderTemplate\": {\"param\": \"value\"}}</p> required <p>footerWikiJson : list     wiki footer template representation     e.g.: {\"FooterTemplate\": {\"param2\": \"value2\"}}</p> <p>Returns:</p> Name Type Description <code>schemaJson</code> <code>dict</code> <p>schema-compatible json e.g.: {\"osl_template\": \"HeaderTemplate\", \"param\": \"value\",        \"osl_footer\": {\"osl_template\": \"FooterTemplate\", \"param2\": \"value2\"}}</p> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def wikiJson2SchemaJsonRecursion(schema: dict, wikiJson: dict, footerWikiJson=None):\n\"\"\"internal recursion function of wikiJson2SchemaJson()\n\n    Parameters\n    ----------\n    wikiJson : list\n        wiki template representation\n        e.g.: {\"HeaderTemplate\": {\"param\": \"value\"}}\n\n    footerWikiJson : list\n        wiki footer template representation\n        e.g.: {\"FooterTemplate\": {\"param2\": \"value2\"}}\n\n    Returns\n    -------\n    schemaJson : dict\n        schema-compatible json\n        e.g.: {\"osl_template\": \"HeaderTemplate\", \"param\": \"value\",\n               \"osl_footer\": {\"osl_template\": \"FooterTemplate\", \"param2\": \"value2\"}}\n    \"\"\"\n    schemaJson = {}\n    if footerWikiJson is not None:\n        schemaJson[\"osl_footer\"] = wikiJson2SchemaJsonRecursion(schema, footerWikiJson)\n\n    for key in wikiJson:\n        value = wikiJson[key]\n        if isinstance(value, list):\n            schemaJson[key] = []\n            for index, element in enumerate(value):\n                element = value[index]\n                if isinstance(element, dict):\n                    if key == \"extensions\":\n                        if (\n                            footerWikiJson is not None\n                        ):  # we asume that every extension provides also a footer template\n                            nextFooter = footerWikiJson[\n                                schemaJson[\"osl_footer\"][\"osl_template\"]\n                            ][\"extensions\"][index]\n                            schemaJson[key].append(\n                                wikiJson2SchemaJsonRecursion(\n                                    schema, element, nextFooter\n                                )\n                            )\n                    else:\n                        schemaJson[key].append(\n                            wikiJson2SchemaJsonRecursion(schema, element)\n                        )\n                else:\n                    schemaJson[key].append(element)\n\n        elif isinstance(value, dict):\n            schemaJson = wikiJson2SchemaJsonRecursion(schema, value, footerWikiJson)\n            schemaJson[\"osl_template\"] = key\n        else:\n            schemaJson[key] = value\n\n    if \"osl_template\" in schemaJson:\n        jsonpath_expr = parse(\n            \"$..properties\"\n        )  # [?osl_template.default = \"' + schemaJson['osl_template'] + '\"]')\n        schema_def = {}\n        # print(\"Search for \", schemaJson['osl_template'])\n        for match in jsonpath_expr.find(schema):\n            value = match.value\n            if (\n                \"osl_template\" in value\n                and \"osl_template\" in schemaJson\n                and value[\"osl_template\"][\"default\"] == schemaJson[\"osl_template\"]\n                or \"osl_schema\" in value\n                and \"osl_schema\" in schemaJson\n                and value[\"osl_schema\"][\"default\"] == schemaJson[\"osl_schema\"]\n            ):\n                schema_def = match.value  # ToDo: Resolve allOf...\n                # print(schema_def)\n\n        for key in list(schemaJson.keys()):\n            if key in schema_def:\n                if \"type\" in schema_def[key]:  # use schema to resolve types\n                    if schema_def[key][\"type\"] == \"integer\":\n                        schemaJson[key] = int(schemaJson[key])\n                    elif schema_def[key][\"type\"] == \"float\":\n                        schemaJson[key] = float(schemaJson[key])\n                    elif schema_def[key][\"type\"] == \"number\":\n                        schemaJson[key] = float(schemaJson[key])\n                    elif schema_def[key][\"type\"] == \"string\":\n                        schemaJson[key] = str(schemaJson[key])\n                    elif schema_def[key][\"type\"] == \"array\":\n                        if not isinstance(schemaJson[key], list):\n                            del schemaJson[key]\n                        elif len(schemaJson[key]) == 0:\n                            del schemaJson[key]\n                else:  # assume type==object\n                    if isinstance(schemaJson[key], list) and len(schemaJson[key]) == 1:\n                        schemaJson[key] = schemaJson[key][0]\n            else:  # fall back\n                if schemaJson[key] == \"\" and key == \"extensions\":\n                    del schemaJson[key]\n                elif isinstance(\n                    schemaJson[key], list\n                ):  # wikiJson defaults are lists, even for single or empty values\n                    if len(schemaJson[key]) == 0:\n                        del schemaJson[key]\n                    # elif len(schemaJson[key]) == 1: schemaJson[key] = schemaJson[key][0]\n\n    return schemaJson\n</code></pre>"}]}